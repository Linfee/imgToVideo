"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@stripe";
exports.ids = ["vendor-chunks/@stripe"];
exports.modules = {

/***/ "(ssr)/./node_modules/@stripe/stripe-js/dist/stripe.esm.js":
/*!***********************************************************!*\
  !*** ./node_modules/@stripe/stripe-js/dist/stripe.esm.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   loadStripe: () => (/* binding */ loadStripe)\n/* harmony export */ });\nvar V3_URL = \"https://js.stripe.com/v3\";\nvar V3_URL_REGEX = /^https:\\/\\/js\\.stripe\\.com\\/v3\\/?(\\?.*)?$/;\nvar EXISTING_SCRIPT_MESSAGE = \"loadStripe.setLoadParameters was called but an existing Stripe.js script already exists in the document; existing script parameters will be used\";\nvar findScript = function findScript() {\n    var scripts = document.querySelectorAll('script[src^=\"'.concat(V3_URL, '\"]'));\n    for(var i = 0; i < scripts.length; i++){\n        var script = scripts[i];\n        if (!V3_URL_REGEX.test(script.src)) {\n            continue;\n        }\n        return script;\n    }\n    return null;\n};\nvar injectScript = function injectScript(params) {\n    var queryString = params && !params.advancedFraudSignals ? \"?advancedFraudSignals=false\" : \"\";\n    var script = document.createElement(\"script\");\n    script.src = \"\".concat(V3_URL).concat(queryString);\n    var headOrBody = document.head || document.body;\n    if (!headOrBody) {\n        throw new Error(\"Expected document.body not to be null. Stripe.js requires a <body> element.\");\n    }\n    headOrBody.appendChild(script);\n    return script;\n};\nvar registerWrapper = function registerWrapper(stripe, startTime) {\n    if (!stripe || !stripe._registerWrapper) {\n        return;\n    }\n    stripe._registerWrapper({\n        name: \"stripe-js\",\n        version: \"2.4.0\",\n        startTime: startTime\n    });\n};\nvar stripePromise = null;\nvar onErrorListener = null;\nvar onLoadListener = null;\nvar onError = function onError(reject) {\n    return function() {\n        reject(new Error(\"Failed to load Stripe.js\"));\n    };\n};\nvar onLoad = function onLoad(resolve, reject) {\n    return function() {\n        if (window.Stripe) {\n            resolve(window.Stripe);\n        } else {\n            reject(new Error(\"Stripe.js not available\"));\n        }\n    };\n};\nvar loadScript = function loadScript(params) {\n    // Ensure that we only attempt to load Stripe.js at most once\n    if (stripePromise !== null) {\n        return stripePromise;\n    }\n    stripePromise = new Promise(function(resolve, reject) {\n        if (true) {\n            // Resolve to null when imported server side. This makes the module\n            // safe to import in an isomorphic code base.\n            resolve(null);\n            return;\n        }\n        if (window.Stripe && params) {\n            console.warn(EXISTING_SCRIPT_MESSAGE);\n        }\n        if (window.Stripe) {\n            resolve(window.Stripe);\n            return;\n        }\n        try {\n            var script = findScript();\n            if (script && params) {\n                console.warn(EXISTING_SCRIPT_MESSAGE);\n            } else if (!script) {\n                script = injectScript(params);\n            } else if (script && onLoadListener !== null && onErrorListener !== null) {\n                var _script$parentNode;\n                // remove event listeners\n                script.removeEventListener(\"load\", onLoadListener);\n                script.removeEventListener(\"error\", onErrorListener); // if script exists, but we are reloading due to an error,\n                // reload script to trigger 'load' event\n                (_script$parentNode = script.parentNode) === null || _script$parentNode === void 0 ? void 0 : _script$parentNode.removeChild(script);\n                script = injectScript(params);\n            }\n            onLoadListener = onLoad(resolve, reject);\n            onErrorListener = onError(reject);\n            script.addEventListener(\"load\", onLoadListener);\n            script.addEventListener(\"error\", onErrorListener);\n        } catch (error) {\n            reject(error);\n            return;\n        }\n    }); // Resets stripePromise on error\n    return stripePromise[\"catch\"](function(error) {\n        stripePromise = null;\n        return Promise.reject(error);\n    });\n};\nvar initStripe = function initStripe(maybeStripe, args, startTime) {\n    if (maybeStripe === null) {\n        return null;\n    }\n    var stripe = maybeStripe.apply(undefined, args);\n    registerWrapper(stripe, startTime);\n    return stripe;\n}; // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nvar stripePromise$1;\nvar loadCalled = false;\nvar getStripePromise = function getStripePromise() {\n    if (stripePromise$1) {\n        return stripePromise$1;\n    }\n    stripePromise$1 = loadScript(null)[\"catch\"](function(error) {\n        // clear cache on error\n        stripePromise$1 = null;\n        return Promise.reject(error);\n    });\n    return stripePromise$1;\n}; // Execute our own script injection after a tick to give users time to do their\n// own script injection.\nPromise.resolve().then(function() {\n    return getStripePromise();\n})[\"catch\"](function(error) {\n    if (!loadCalled) {\n        console.warn(error);\n    }\n});\nvar loadStripe = function loadStripe() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    loadCalled = true;\n    var startTime = Date.now(); // if previous attempts are unsuccessful, will re-load script\n    return getStripePromise().then(function(maybeStripe) {\n        return initStripe(maybeStripe, args, startTime);\n    });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN0cmlwZS9zdHJpcGUtanMvZGlzdC9zdHJpcGUuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxJQUFJQSxTQUFTO0FBQ2IsSUFBSUMsZUFBZTtBQUNuQixJQUFJQywwQkFBMEI7QUFDOUIsSUFBSUMsYUFBYSxTQUFTQTtJQUN4QixJQUFJQyxVQUFVQyxTQUFTQyxnQkFBZ0IsQ0FBQyxnQkFBaUJDLE1BQU0sQ0FBQ1AsUUFBUTtJQUV4RSxJQUFLLElBQUlRLElBQUksR0FBR0EsSUFBSUosUUFBUUssTUFBTSxFQUFFRCxJQUFLO1FBQ3ZDLElBQUlFLFNBQVNOLE9BQU8sQ0FBQ0ksRUFBRTtRQUV2QixJQUFJLENBQUNQLGFBQWFVLElBQUksQ0FBQ0QsT0FBT0UsR0FBRyxHQUFHO1lBQ2xDO1FBQ0Y7UUFFQSxPQUFPRjtJQUNUO0lBRUEsT0FBTztBQUNUO0FBRUEsSUFBSUcsZUFBZSxTQUFTQSxhQUFhQyxNQUFNO0lBQzdDLElBQUlDLGNBQWNELFVBQVUsQ0FBQ0EsT0FBT0Usb0JBQW9CLEdBQUcsZ0NBQWdDO0lBQzNGLElBQUlOLFNBQVNMLFNBQVNZLGFBQWEsQ0FBQztJQUNwQ1AsT0FBT0UsR0FBRyxHQUFHLEdBQUdMLE1BQU0sQ0FBQ1AsUUFBUU8sTUFBTSxDQUFDUTtJQUN0QyxJQUFJRyxhQUFhYixTQUFTYyxJQUFJLElBQUlkLFNBQVNlLElBQUk7SUFFL0MsSUFBSSxDQUFDRixZQUFZO1FBQ2YsTUFBTSxJQUFJRyxNQUFNO0lBQ2xCO0lBRUFILFdBQVdJLFdBQVcsQ0FBQ1o7SUFDdkIsT0FBT0E7QUFDVDtBQUVBLElBQUlhLGtCQUFrQixTQUFTQSxnQkFBZ0JDLE1BQU0sRUFBRUMsU0FBUztJQUM5RCxJQUFJLENBQUNELFVBQVUsQ0FBQ0EsT0FBT0UsZ0JBQWdCLEVBQUU7UUFDdkM7SUFDRjtJQUVBRixPQUFPRSxnQkFBZ0IsQ0FBQztRQUN0QkMsTUFBTTtRQUNOQyxTQUFTO1FBQ1RILFdBQVdBO0lBQ2I7QUFDRjtB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RSxDQUFDLFFBQVEsQ0FBQyxTQUFVUixLQUFLO0lBQ3pCLElBQUksQ0FBQ08sWUFBWTtRQUNmZCxRQUFRQyxJQUFJLENBQUNNO0lBQ2Y7QUFDRjtBQUNBLElBQUlVLGFBQWEsU0FBU0E7SUFDeEIsSUFBSyxJQUFJQyxPQUFPQyxVQUFVbEQsTUFBTSxFQUFFeUMsT0FBTyxJQUFJVSxNQUFNRixPQUFPRyxPQUFPLEdBQUdBLE9BQU9ILE1BQU1HLE9BQVE7UUFDdkZYLElBQUksQ0FBQ1csS0FBSyxHQUFHRixTQUFTLENBQUNFLEtBQUs7SUFDOUI7SUFFQVAsYUFBYTtJQUNiLElBQUk3QixZQUFZcUMsS0FBS0MsR0FBRyxJQUFJLDZEQUE2RDtJQUV6RixPQUFPUixtQkFBbUJDLElBQUksQ0FBQyxTQUFVUCxXQUFXO1FBQ2xELE9BQU9ELFdBQVdDLGFBQWFDLE1BQU16QjtJQUN2QztBQUNGO0FBRXNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW1ndG92aWRlby8uL25vZGVfbW9kdWxlcy9Ac3RyaXBlL3N0cmlwZS1qcy9kaXN0L3N0cmlwZS5lc20uanM/ZWYyNSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgVjNfVVJMID0gJ2h0dHBzOi8vanMuc3RyaXBlLmNvbS92Myc7XG52YXIgVjNfVVJMX1JFR0VYID0gL15odHRwczpcXC9cXC9qc1xcLnN0cmlwZVxcLmNvbVxcL3YzXFwvPyhcXD8uKik/JC87XG52YXIgRVhJU1RJTkdfU0NSSVBUX01FU1NBR0UgPSAnbG9hZFN0cmlwZS5zZXRMb2FkUGFyYW1ldGVycyB3YXMgY2FsbGVkIGJ1dCBhbiBleGlzdGluZyBTdHJpcGUuanMgc2NyaXB0IGFscmVhZHkgZXhpc3RzIGluIHRoZSBkb2N1bWVudDsgZXhpc3Rpbmcgc2NyaXB0IHBhcmFtZXRlcnMgd2lsbCBiZSB1c2VkJztcbnZhciBmaW5kU2NyaXB0ID0gZnVuY3Rpb24gZmluZFNjcmlwdCgpIHtcbiAgdmFyIHNjcmlwdHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwic2NyaXB0W3NyY149XFxcIlwiLmNvbmNhdChWM19VUkwsIFwiXFxcIl1cIikpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2NyaXB0cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzY3JpcHQgPSBzY3JpcHRzW2ldO1xuXG4gICAgaWYgKCFWM19VUkxfUkVHRVgudGVzdChzY3JpcHQuc3JjKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjcmlwdDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxudmFyIGluamVjdFNjcmlwdCA9IGZ1bmN0aW9uIGluamVjdFNjcmlwdChwYXJhbXMpIHtcbiAgdmFyIHF1ZXJ5U3RyaW5nID0gcGFyYW1zICYmICFwYXJhbXMuYWR2YW5jZWRGcmF1ZFNpZ25hbHMgPyAnP2FkdmFuY2VkRnJhdWRTaWduYWxzPWZhbHNlJyA6ICcnO1xuICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gIHNjcmlwdC5zcmMgPSBcIlwiLmNvbmNhdChWM19VUkwpLmNvbmNhdChxdWVyeVN0cmluZyk7XG4gIHZhciBoZWFkT3JCb2R5ID0gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5ib2R5O1xuXG4gIGlmICghaGVhZE9yQm9keSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgZG9jdW1lbnQuYm9keSBub3QgdG8gYmUgbnVsbC4gU3RyaXBlLmpzIHJlcXVpcmVzIGEgPGJvZHk+IGVsZW1lbnQuJyk7XG4gIH1cblxuICBoZWFkT3JCb2R5LmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gIHJldHVybiBzY3JpcHQ7XG59O1xuXG52YXIgcmVnaXN0ZXJXcmFwcGVyID0gZnVuY3Rpb24gcmVnaXN0ZXJXcmFwcGVyKHN0cmlwZSwgc3RhcnRUaW1lKSB7XG4gIGlmICghc3RyaXBlIHx8ICFzdHJpcGUuX3JlZ2lzdGVyV3JhcHBlcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN0cmlwZS5fcmVnaXN0ZXJXcmFwcGVyKHtcbiAgICBuYW1lOiAnc3RyaXBlLWpzJyxcbiAgICB2ZXJzaW9uOiBcIjIuNC4wXCIsXG4gICAgc3RhcnRUaW1lOiBzdGFydFRpbWVcbiAgfSk7XG59O1xuXG52YXIgc3RyaXBlUHJvbWlzZSA9IG51bGw7XG52YXIgb25FcnJvckxpc3RlbmVyID0gbnVsbDtcbnZhciBvbkxvYWRMaXN0ZW5lciA9IG51bGw7XG5cbnZhciBvbkVycm9yID0gZnVuY3Rpb24gb25FcnJvcihyZWplY3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZWplY3QobmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCBTdHJpcGUuanMnKSk7XG4gIH07XG59O1xuXG52YXIgb25Mb2FkID0gZnVuY3Rpb24gb25Mb2FkKHJlc29sdmUsIHJlamVjdCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICh3aW5kb3cuU3RyaXBlKSB7XG4gICAgICByZXNvbHZlKHdpbmRvdy5TdHJpcGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWplY3QobmV3IEVycm9yKCdTdHJpcGUuanMgbm90IGF2YWlsYWJsZScpKTtcbiAgICB9XG4gIH07XG59O1xuXG52YXIgbG9hZFNjcmlwdCA9IGZ1bmN0aW9uIGxvYWRTY3JpcHQocGFyYW1zKSB7XG4gIC8vIEVuc3VyZSB0aGF0IHdlIG9ubHkgYXR0ZW1wdCB0byBsb2FkIFN0cmlwZS5qcyBhdCBtb3N0IG9uY2VcbiAgaWYgKHN0cmlwZVByb21pc2UgIT09IG51bGwpIHtcbiAgICByZXR1cm4gc3RyaXBlUHJvbWlzZTtcbiAgfVxuXG4gIHN0cmlwZVByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIFJlc29sdmUgdG8gbnVsbCB3aGVuIGltcG9ydGVkIHNlcnZlciBzaWRlLiBUaGlzIG1ha2VzIHRoZSBtb2R1bGVcbiAgICAgIC8vIHNhZmUgdG8gaW1wb3J0IGluIGFuIGlzb21vcnBoaWMgY29kZSBiYXNlLlxuICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAod2luZG93LlN0cmlwZSAmJiBwYXJhbXMpIHtcbiAgICAgIGNvbnNvbGUud2FybihFWElTVElOR19TQ1JJUFRfTUVTU0FHRSk7XG4gICAgfVxuXG4gICAgaWYgKHdpbmRvdy5TdHJpcGUpIHtcbiAgICAgIHJlc29sdmUod2luZG93LlN0cmlwZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBzY3JpcHQgPSBmaW5kU2NyaXB0KCk7XG5cbiAgICAgIGlmIChzY3JpcHQgJiYgcGFyYW1zKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihFWElTVElOR19TQ1JJUFRfTUVTU0FHRSk7XG4gICAgICB9IGVsc2UgaWYgKCFzY3JpcHQpIHtcbiAgICAgICAgc2NyaXB0ID0gaW5qZWN0U2NyaXB0KHBhcmFtcyk7XG4gICAgICB9IGVsc2UgaWYgKHNjcmlwdCAmJiBvbkxvYWRMaXN0ZW5lciAhPT0gbnVsbCAmJiBvbkVycm9yTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIF9zY3JpcHQkcGFyZW50Tm9kZTtcblxuICAgICAgICAvLyByZW1vdmUgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgIHNjcmlwdC5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgb25Mb2FkTGlzdGVuZXIpO1xuICAgICAgICBzY3JpcHQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yTGlzdGVuZXIpOyAvLyBpZiBzY3JpcHQgZXhpc3RzLCBidXQgd2UgYXJlIHJlbG9hZGluZyBkdWUgdG8gYW4gZXJyb3IsXG4gICAgICAgIC8vIHJlbG9hZCBzY3JpcHQgdG8gdHJpZ2dlciAnbG9hZCcgZXZlbnRcblxuICAgICAgICAoX3NjcmlwdCRwYXJlbnROb2RlID0gc2NyaXB0LnBhcmVudE5vZGUpID09PSBudWxsIHx8IF9zY3JpcHQkcGFyZW50Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NjcmlwdCRwYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgIHNjcmlwdCA9IGluamVjdFNjcmlwdChwYXJhbXMpO1xuICAgICAgfVxuXG4gICAgICBvbkxvYWRMaXN0ZW5lciA9IG9uTG9hZChyZXNvbHZlLCByZWplY3QpO1xuICAgICAgb25FcnJvckxpc3RlbmVyID0gb25FcnJvcihyZWplY3QpO1xuICAgICAgc2NyaXB0LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBvbkxvYWRMaXN0ZW5lcik7XG4gICAgICBzY3JpcHQuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yTGlzdGVuZXIpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSk7IC8vIFJlc2V0cyBzdHJpcGVQcm9taXNlIG9uIGVycm9yXG5cbiAgcmV0dXJuIHN0cmlwZVByb21pc2VbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICBzdHJpcGVQcm9taXNlID0gbnVsbDtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICB9KTtcbn07XG52YXIgaW5pdFN0cmlwZSA9IGZ1bmN0aW9uIGluaXRTdHJpcGUobWF5YmVTdHJpcGUsIGFyZ3MsIHN0YXJ0VGltZSkge1xuICBpZiAobWF5YmVTdHJpcGUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBzdHJpcGUgPSBtYXliZVN0cmlwZS5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICByZWdpc3RlcldyYXBwZXIoc3RyaXBlLCBzdGFydFRpbWUpO1xuICByZXR1cm4gc3RyaXBlO1xufTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcblxudmFyIHN0cmlwZVByb21pc2UkMTtcbnZhciBsb2FkQ2FsbGVkID0gZmFsc2U7XG5cbnZhciBnZXRTdHJpcGVQcm9taXNlID0gZnVuY3Rpb24gZ2V0U3RyaXBlUHJvbWlzZSgpIHtcbiAgaWYgKHN0cmlwZVByb21pc2UkMSkge1xuICAgIHJldHVybiBzdHJpcGVQcm9taXNlJDE7XG4gIH1cblxuICBzdHJpcGVQcm9taXNlJDEgPSBsb2FkU2NyaXB0KG51bGwpW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgLy8gY2xlYXIgY2FjaGUgb24gZXJyb3JcbiAgICBzdHJpcGVQcm9taXNlJDEgPSBudWxsO1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gIH0pO1xuICByZXR1cm4gc3RyaXBlUHJvbWlzZSQxO1xufTsgLy8gRXhlY3V0ZSBvdXIgb3duIHNjcmlwdCBpbmplY3Rpb24gYWZ0ZXIgYSB0aWNrIHRvIGdpdmUgdXNlcnMgdGltZSB0byBkbyB0aGVpclxuLy8gb3duIHNjcmlwdCBpbmplY3Rpb24uXG5cblxuUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBnZXRTdHJpcGVQcm9taXNlKCk7XG59KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnJvcikge1xuICBpZiAoIWxvYWRDYWxsZWQpIHtcbiAgICBjb25zb2xlLndhcm4oZXJyb3IpO1xuICB9XG59KTtcbnZhciBsb2FkU3RyaXBlID0gZnVuY3Rpb24gbG9hZFN0cmlwZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGxvYWRDYWxsZWQgPSB0cnVlO1xuICB2YXIgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTsgLy8gaWYgcHJldmlvdXMgYXR0ZW1wdHMgYXJlIHVuc3VjY2Vzc2Z1bCwgd2lsbCByZS1sb2FkIHNjcmlwdFxuXG4gIHJldHVybiBnZXRTdHJpcGVQcm9taXNlKCkudGhlbihmdW5jdGlvbiAobWF5YmVTdHJpcGUpIHtcbiAgICByZXR1cm4gaW5pdFN0cmlwZShtYXliZVN0cmlwZSwgYXJncywgc3RhcnRUaW1lKTtcbiAgfSk7XG59O1xuXG5leHBvcnQgeyBsb2FkU3RyaXBlIH07XG4iXSwibmFtZXMiOlsiVjNfVVJMIiwiVjNfVVJMX1JFR0VYIiwiRVhJU1RJTkdfU0NSSVBUX01FU1NBR0UiLCJmaW5kU2NyaXB0Iiwic2NyaXB0cyIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvckFsbCIsImNvbmNhdCIsImkiLCJsZW5ndGgiLCJzY3JpcHQiLCJ0ZXN0Iiwic3JjIiwiaW5qZWN0U2NyaXB0IiwicGFyYW1zIiwicXVlcnlTdHJpbmciLCJhZHZhbmNlZEZyYXVkU2lnbmFscyIsImNyZWF0ZUVsZW1lbnQiLCJoZWFkT3JCb2R5IiwiaGVhZCIsImJvZHkiLCJFcnJvciIsImFwcGVuZENoaWxkIiwicmVnaXN0ZXJXcmFwcGVyIiwic3RyaXBlIiwic3RhcnRUaW1lIiwiX3JlZ2lzdGVyV3JhcHBlciIsIm5hbWUiLCJ2ZXJzaW9uIiwic3RyaXBlUHJvbWlzZSIsIm9uRXJyb3JMaXN0ZW5lciIsIm9uTG9hZExpc3RlbmVyIiwib25FcnJvciIsInJlamVjdCIsIm9uTG9hZCIsInJlc29sdmUiLCJ3aW5kb3ciLCJTdHJpcGUiLCJsb2FkU2NyaXB0IiwiUHJvbWlzZSIsImNvbnNvbGUiLCJ3YXJuIiwiX3NjcmlwdCRwYXJlbnROb2RlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImFkZEV2ZW50TGlzdGVuZXIiLCJlcnJvciIsImluaXRTdHJpcGUiLCJtYXliZVN0cmlwZSIsImFyZ3MiLCJhcHBseSIsInVuZGVmaW5lZCIsInN0cmlwZVByb21pc2UkMSIsImxvYWRDYWxsZWQiLCJnZXRTdHJpcGVQcm9taXNlIiwidGhlbiIsImxvYWRTdHJpcGUiLCJfbGVuIiwiYXJndW1lbnRzIiwiQXJyYXkiLCJfa2V5IiwiRGF0ZSIsIm5vdyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@stripe/stripe-js/dist/stripe.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@stripe/react-stripe-js/dist/react-stripe.esm.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@stripe/react-stripe-js/dist/react-stripe.esm.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddressElement: () => (/* binding */ AddressElement),\n/* harmony export */   AffirmMessageElement: () => (/* binding */ AffirmMessageElement),\n/* harmony export */   AfterpayClearpayMessageElement: () => (/* binding */ AfterpayClearpayMessageElement),\n/* harmony export */   AuBankAccountElement: () => (/* binding */ AuBankAccountElement),\n/* harmony export */   CardCvcElement: () => (/* binding */ CardCvcElement),\n/* harmony export */   CardElement: () => (/* binding */ CardElement),\n/* harmony export */   CardExpiryElement: () => (/* binding */ CardExpiryElement),\n/* harmony export */   CardNumberElement: () => (/* binding */ CardNumberElement),\n/* harmony export */   CheckoutProvider: () => (/* binding */ CheckoutProvider),\n/* harmony export */   CurrencySelectorElement: () => (/* binding */ CurrencySelectorElement),\n/* harmony export */   Elements: () => (/* binding */ Elements),\n/* harmony export */   ElementsConsumer: () => (/* binding */ ElementsConsumer),\n/* harmony export */   EmbeddedCheckout: () => (/* binding */ EmbeddedCheckout),\n/* harmony export */   EmbeddedCheckoutProvider: () => (/* binding */ EmbeddedCheckoutProvider),\n/* harmony export */   EpsBankElement: () => (/* binding */ EpsBankElement),\n/* harmony export */   ExpressCheckoutElement: () => (/* binding */ ExpressCheckoutElement),\n/* harmony export */   FpxBankElement: () => (/* binding */ FpxBankElement),\n/* harmony export */   IbanElement: () => (/* binding */ IbanElement),\n/* harmony export */   IdealBankElement: () => (/* binding */ IdealBankElement),\n/* harmony export */   LinkAuthenticationElement: () => (/* binding */ LinkAuthenticationElement),\n/* harmony export */   P24BankElement: () => (/* binding */ P24BankElement),\n/* harmony export */   PaymentElement: () => (/* binding */ PaymentElement),\n/* harmony export */   PaymentMethodMessagingElement: () => (/* binding */ PaymentMethodMessagingElement),\n/* harmony export */   PaymentRequestButtonElement: () => (/* binding */ PaymentRequestButtonElement),\n/* harmony export */   ShippingAddressElement: () => (/* binding */ ShippingAddressElement),\n/* harmony export */   useCheckout: () => (/* binding */ useCheckout),\n/* harmony export */   useElements: () => (/* binding */ useElements),\n/* harmony export */   useStripe: () => (/* binding */ useStripe)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\");\n\n\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread2(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nfunction _typeof(obj) {\n    \"@babel/helpers - typeof\";\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n        _typeof = function(obj) {\n            return typeof obj;\n        };\n    } else {\n        _typeof = function(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n        };\n    }\n    return _typeof(obj);\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArrayLimit(arr, i) {\n    var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]);\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nvar useAttachEvent = function useAttachEvent(element, event, cb) {\n    var cbDefined = !!cb;\n    var cbRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(cb); // In many integrations the callback prop changes on each render.\n    // Using a ref saves us from calling element.on/.off every render.\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        cbRef.current = cb;\n    }, [\n        cb\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        if (!cbDefined || !element) {\n            return function() {};\n        }\n        var decoratedCb = function decoratedCb() {\n            if (cbRef.current) {\n                cbRef.current.apply(cbRef, arguments);\n            }\n        };\n        element.on(event, decoratedCb);\n        return function() {\n            element.off(event, decoratedCb);\n        };\n    }, [\n        cbDefined,\n        event,\n        element,\n        cbRef\n    ]);\n};\nvar usePrevious = function usePrevious(value) {\n    var ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(value);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        ref.current = value;\n    }, [\n        value\n    ]);\n    return ref.current;\n};\nvar isUnknownObject = function isUnknownObject(raw) {\n    return raw !== null && _typeof(raw) === \"object\";\n};\nvar isPromise = function isPromise(raw) {\n    return isUnknownObject(raw) && typeof raw.then === \"function\";\n}; // We are using types to enforce the `stripe` prop in this lib,\n// but in an untyped integration `stripe` could be anything, so we need\n// to do some sanity validation to prevent type errors.\nvar isStripe = function isStripe(raw) {\n    return isUnknownObject(raw) && typeof raw.elements === \"function\" && typeof raw.createToken === \"function\" && typeof raw.createPaymentMethod === \"function\" && typeof raw.confirmCardPayment === \"function\";\n};\nvar PLAIN_OBJECT_STR = \"[object Object]\";\nvar isEqual = function isEqual(left, right) {\n    if (!isUnknownObject(left) || !isUnknownObject(right)) {\n        return left === right;\n    }\n    var leftArray = Array.isArray(left);\n    var rightArray = Array.isArray(right);\n    if (leftArray !== rightArray) return false;\n    var leftPlainObject = Object.prototype.toString.call(left) === PLAIN_OBJECT_STR;\n    var rightPlainObject = Object.prototype.toString.call(right) === PLAIN_OBJECT_STR;\n    if (leftPlainObject !== rightPlainObject) return false; // not sure what sort of special object this is (regexp is one option), so\n    // fallback to reference check.\n    if (!leftPlainObject && !leftArray) return left === right;\n    var leftKeys = Object.keys(left);\n    var rightKeys = Object.keys(right);\n    if (leftKeys.length !== rightKeys.length) return false;\n    var keySet = {};\n    for(var i = 0; i < leftKeys.length; i += 1){\n        keySet[leftKeys[i]] = true;\n    }\n    for(var _i = 0; _i < rightKeys.length; _i += 1){\n        keySet[rightKeys[_i]] = true;\n    }\n    var allKeys = Object.keys(keySet);\n    if (allKeys.length !== leftKeys.length) {\n        return false;\n    }\n    var l = left;\n    var r = right;\n    var pred = function pred(key) {\n        return isEqual(l[key], r[key]);\n    };\n    return allKeys.every(pred);\n};\nvar extractAllowedOptionsUpdates = function extractAllowedOptionsUpdates(options, prevOptions, immutableKeys) {\n    if (!isUnknownObject(options)) {\n        return null;\n    }\n    return Object.keys(options).reduce(function(newOptions, key) {\n        var isUpdated = !isUnknownObject(prevOptions) || !isEqual(options[key], prevOptions[key]);\n        if (immutableKeys.includes(key)) {\n            if (isUpdated) {\n                console.warn(\"Unsupported prop change: options.\".concat(key, \" is not a mutable property.\"));\n            }\n            return newOptions;\n        }\n        if (!isUpdated) {\n            return newOptions;\n        }\n        return _objectSpread2(_objectSpread2({}, newOptions || {}), {}, _defineProperty({}, key, options[key]));\n    }, null);\n};\nvar INVALID_STRIPE_ERROR$2 = \"Invalid prop `stripe` supplied to `Elements`. We recommend using the `loadStripe` utility from `@stripe/stripe-js`. See https://stripe.com/docs/stripe-js/react#elements-props-stripe for details.\"; // We are using types to enforce the `stripe` prop in this lib, but in a real\n// integration `stripe` could be anything, so we need to do some sanity\n// validation to prevent type errors.\nvar validateStripe = function validateStripe(maybeStripe) {\n    var errorMsg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : INVALID_STRIPE_ERROR$2;\n    if (maybeStripe === null || isStripe(maybeStripe)) {\n        return maybeStripe;\n    }\n    throw new Error(errorMsg);\n};\nvar parseStripeProp = function parseStripeProp(raw) {\n    var errorMsg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : INVALID_STRIPE_ERROR$2;\n    if (isPromise(raw)) {\n        return {\n            tag: \"async\",\n            stripePromise: Promise.resolve(raw).then(function(result) {\n                return validateStripe(result, errorMsg);\n            })\n        };\n    }\n    var stripe = validateStripe(raw, errorMsg);\n    if (stripe === null) {\n        return {\n            tag: \"empty\"\n        };\n    }\n    return {\n        tag: \"sync\",\n        stripe: stripe\n    };\n};\nvar registerWithStripeJs = function registerWithStripeJs(stripe) {\n    if (!stripe || !stripe._registerWrapper || !stripe.registerAppInfo) {\n        return;\n    }\n    stripe._registerWrapper({\n        name: \"react-stripe-js\",\n        version: \"3.6.0\"\n    });\n    stripe.registerAppInfo({\n        name: \"react-stripe-js\",\n        version: \"3.6.0\",\n        url: \"https://stripe.com/docs/stripe-js/react\"\n    });\n};\nvar ElementsContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nElementsContext.displayName = \"ElementsContext\";\nvar parseElementsContext = function parseElementsContext(ctx, useCase) {\n    if (!ctx) {\n        throw new Error(\"Could not find Elements context; You need to wrap the part of your app that \".concat(useCase, \" in an <Elements> provider.\"));\n    }\n    return ctx;\n};\n/**\n * The `Elements` provider allows you to use [Element components](https://stripe.com/docs/stripe-js/react#element-components) and access the [Stripe object](https://stripe.com/docs/js/initializing) in any nested component.\n * Render an `Elements` provider at the root of your React app so that it is available everywhere you need it.\n *\n * To use the `Elements` provider, call `loadStripe` from `@stripe/stripe-js` with your publishable key.\n * The `loadStripe` function will asynchronously load the Stripe.js script and initialize a `Stripe` object.\n * Pass the returned `Promise` to `Elements`.\n *\n * @docs https://stripe.com/docs/stripe-js/react#elements-provider\n */ var Elements = function Elements(_ref) {\n    var rawStripeProp = _ref.stripe, options = _ref.options, children = _ref.children;\n    var parsed = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function() {\n        return parseStripeProp(rawStripeProp);\n    }, [\n        rawStripeProp\n    ]); // For a sync stripe instance, initialize into context\n    var _React$useState = react__WEBPACK_IMPORTED_MODULE_0__.useState(function() {\n        return {\n            stripe: parsed.tag === \"sync\" ? parsed.stripe : null,\n            elements: parsed.tag === \"sync\" ? parsed.stripe.elements(options) : null\n        };\n    }), _React$useState2 = _slicedToArray(_React$useState, 2), ctx = _React$useState2[0], setContext = _React$useState2[1];\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        var isMounted = true;\n        var safeSetContext = function safeSetContext(stripe) {\n            setContext(function(ctx) {\n                // no-op if we already have a stripe instance (https://github.com/stripe/react-stripe-js/issues/296)\n                if (ctx.stripe) return ctx;\n                return {\n                    stripe: stripe,\n                    elements: stripe.elements(options)\n                };\n            });\n        }; // For an async stripePromise, store it in context once resolved\n        if (parsed.tag === \"async\" && !ctx.stripe) {\n            parsed.stripePromise.then(function(stripe) {\n                if (stripe && isMounted) {\n                    // Only update Elements context if the component is still mounted\n                    // and stripe is not null. We allow stripe to be null to make\n                    // handling SSR easier.\n                    safeSetContext(stripe);\n                }\n            });\n        } else if (parsed.tag === \"sync\" && !ctx.stripe) {\n            // Or, handle a sync stripe instance going from null -> populated\n            safeSetContext(parsed.stripe);\n        }\n        return function() {\n            isMounted = false;\n        };\n    }, [\n        parsed,\n        ctx,\n        options\n    ]); // Warn on changes to stripe prop\n    var prevStripe = usePrevious(rawStripeProp);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        if (prevStripe !== null && prevStripe !== rawStripeProp) {\n            console.warn(\"Unsupported prop change on Elements: You cannot change the `stripe` prop after setting it.\");\n        }\n    }, [\n        prevStripe,\n        rawStripeProp\n    ]); // Apply updates to elements when options prop has relevant changes\n    var prevOptions = usePrevious(options);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        if (!ctx.elements) {\n            return;\n        }\n        var updates = extractAllowedOptionsUpdates(options, prevOptions, [\n            \"clientSecret\",\n            \"fonts\"\n        ]);\n        if (updates) {\n            ctx.elements.update(updates);\n        }\n    }, [\n        options,\n        prevOptions,\n        ctx.elements\n    ]); // Attach react-stripe-js version to stripe.js instance\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        registerWithStripeJs(ctx.stripe);\n    }, [\n        ctx.stripe\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ElementsContext.Provider, {\n        value: ctx\n    }, children);\n};\nElements.propTypes = {\n    stripe: prop_types__WEBPACK_IMPORTED_MODULE_1__.any,\n    options: prop_types__WEBPACK_IMPORTED_MODULE_1__.object\n};\nvar useElementsContextWithUseCase = function useElementsContextWithUseCase(useCaseMessage) {\n    var ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ElementsContext);\n    return parseElementsContext(ctx, useCaseMessage);\n};\n/**\n * @docs https://stripe.com/docs/stripe-js/react#useelements-hook\n */ var useElements = function useElements() {\n    var _useElementsContextWi = useElementsContextWithUseCase(\"calls useElements()\"), elements = _useElementsContextWi.elements;\n    return elements;\n};\n/**\n * @docs https://stripe.com/docs/stripe-js/react#elements-consumer\n */ var ElementsConsumer = function ElementsConsumer(_ref2) {\n    var children = _ref2.children;\n    var ctx = useElementsContextWithUseCase(\"mounts <ElementsConsumer>\"); // Assert to satisfy the busted React.FC return type (it should be ReactNode)\n    return children(ctx);\n};\nElementsConsumer.propTypes = {\n    children: prop_types__WEBPACK_IMPORTED_MODULE_1__.func.isRequired\n};\nvar _excluded$1 = [\n    \"on\",\n    \"session\"\n];\nvar CheckoutSdkContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nCheckoutSdkContext.displayName = \"CheckoutSdkContext\";\nvar parseCheckoutSdkContext = function parseCheckoutSdkContext(ctx, useCase) {\n    if (!ctx) {\n        throw new Error(\"Could not find CheckoutProvider context; You need to wrap the part of your app that \".concat(useCase, \" in an <CheckoutProvider> provider.\"));\n    }\n    return ctx;\n};\nvar CheckoutContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nCheckoutContext.displayName = \"CheckoutContext\";\nvar extractCheckoutContextValue = function extractCheckoutContextValue(checkoutSdk, sessionState) {\n    if (!checkoutSdk) {\n        return null;\n    }\n    checkoutSdk.on;\n    checkoutSdk.session;\n    var actions = _objectWithoutProperties(checkoutSdk, _excluded$1);\n    if (!sessionState) {\n        return Object.assign(checkoutSdk.session(), actions);\n    }\n    return Object.assign(sessionState, actions);\n};\nvar INVALID_STRIPE_ERROR$1 = \"Invalid prop `stripe` supplied to `CheckoutProvider`. We recommend using the `loadStripe` utility from `@stripe/stripe-js`. See https://stripe.com/docs/stripe-js/react#elements-props-stripe for details.\";\nvar CheckoutProvider = function CheckoutProvider(_ref) {\n    var rawStripeProp = _ref.stripe, options = _ref.options, children = _ref.children;\n    var parsed = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function() {\n        return parseStripeProp(rawStripeProp, INVALID_STRIPE_ERROR$1);\n    }, [\n        rawStripeProp\n    ]); // State used to trigger a re-render when sdk.session is updated\n    var _React$useState = react__WEBPACK_IMPORTED_MODULE_0__.useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), session = _React$useState2[0], setSession = _React$useState2[1];\n    var _React$useState3 = react__WEBPACK_IMPORTED_MODULE_0__.useState(function() {\n        return {\n            stripe: parsed.tag === \"sync\" ? parsed.stripe : null,\n            checkoutSdk: null\n        };\n    }), _React$useState4 = _slicedToArray(_React$useState3, 2), ctx = _React$useState4[0], setContext = _React$useState4[1];\n    var safeSetContext = function safeSetContext(stripe, checkoutSdk) {\n        setContext(function(ctx) {\n            if (ctx.stripe && ctx.checkoutSdk) {\n                return ctx;\n            }\n            return {\n                stripe: stripe,\n                checkoutSdk: checkoutSdk\n            };\n        });\n    }; // Ref used to avoid calling initCheckout multiple times when options changes\n    var initCheckoutCalledRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        var isMounted = true;\n        if (parsed.tag === \"async\" && !ctx.stripe) {\n            parsed.stripePromise.then(function(stripe) {\n                if (stripe && isMounted && !initCheckoutCalledRef.current) {\n                    // Only update context if the component is still mounted\n                    // and stripe is not null. We allow stripe to be null to make\n                    // handling SSR easier.\n                    initCheckoutCalledRef.current = true;\n                    stripe.initCheckout(options).then(function(checkoutSdk) {\n                        if (checkoutSdk) {\n                            safeSetContext(stripe, checkoutSdk);\n                            checkoutSdk.on(\"change\", setSession);\n                        }\n                    });\n                }\n            });\n        } else if (parsed.tag === \"sync\" && parsed.stripe && !initCheckoutCalledRef.current) {\n            initCheckoutCalledRef.current = true;\n            parsed.stripe.initCheckout(options).then(function(checkoutSdk) {\n                if (checkoutSdk) {\n                    safeSetContext(parsed.stripe, checkoutSdk);\n                    checkoutSdk.on(\"change\", setSession);\n                }\n            });\n        }\n        return function() {\n            isMounted = false;\n        };\n    }, [\n        parsed,\n        ctx,\n        options,\n        setSession\n    ]); // Warn on changes to stripe prop\n    var prevStripe = usePrevious(rawStripeProp);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        if (prevStripe !== null && prevStripe !== rawStripeProp) {\n            console.warn(\"Unsupported prop change on CheckoutProvider: You cannot change the `stripe` prop after setting it.\");\n        }\n    }, [\n        prevStripe,\n        rawStripeProp\n    ]); // Apply updates to elements when options prop has relevant changes\n    var prevOptions = usePrevious(options);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        var _prevOptions$elements, _options$elementsOpti;\n        if (!ctx.checkoutSdk) {\n            return;\n        }\n        var previousAppearance = prevOptions === null || prevOptions === void 0 ? void 0 : (_prevOptions$elements = prevOptions.elementsOptions) === null || _prevOptions$elements === void 0 ? void 0 : _prevOptions$elements.appearance;\n        var currentAppearance = options === null || options === void 0 ? void 0 : (_options$elementsOpti = options.elementsOptions) === null || _options$elementsOpti === void 0 ? void 0 : _options$elementsOpti.appearance;\n        if (currentAppearance && !isEqual(currentAppearance, previousAppearance)) {\n            ctx.checkoutSdk.changeAppearance(currentAppearance);\n        }\n    }, [\n        options,\n        prevOptions,\n        ctx.checkoutSdk\n    ]); // Attach react-stripe-js version to stripe.js instance\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        registerWithStripeJs(ctx.stripe);\n    }, [\n        ctx.stripe\n    ]);\n    var checkoutContextValue = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function() {\n        return extractCheckoutContextValue(ctx.checkoutSdk, session);\n    }, [\n        ctx.checkoutSdk,\n        session\n    ]);\n    if (!ctx.checkoutSdk) {\n        return null;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(CheckoutSdkContext.Provider, {\n        value: ctx\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(CheckoutContext.Provider, {\n        value: checkoutContextValue\n    }, children));\n};\nCheckoutProvider.propTypes = {\n    stripe: prop_types__WEBPACK_IMPORTED_MODULE_1__.any,\n    options: prop_types__WEBPACK_IMPORTED_MODULE_1__.shape({\n        fetchClientSecret: prop_types__WEBPACK_IMPORTED_MODULE_1__.func.isRequired,\n        elementsOptions: prop_types__WEBPACK_IMPORTED_MODULE_1__.object\n    }).isRequired\n};\nvar useCheckoutSdkContextWithUseCase = function useCheckoutSdkContextWithUseCase(useCaseString) {\n    var ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CheckoutSdkContext);\n    return parseCheckoutSdkContext(ctx, useCaseString);\n};\nvar useElementsOrCheckoutSdkContextWithUseCase = function useElementsOrCheckoutSdkContextWithUseCase(useCaseString) {\n    var checkoutSdkContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CheckoutSdkContext);\n    var elementsContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ElementsContext);\n    if (checkoutSdkContext && elementsContext) {\n        throw new Error(\"You cannot wrap the part of your app that \".concat(useCaseString, \" in both <CheckoutProvider> and <Elements> providers.\"));\n    }\n    if (checkoutSdkContext) {\n        return parseCheckoutSdkContext(checkoutSdkContext, useCaseString);\n    }\n    return parseElementsContext(elementsContext, useCaseString);\n};\nvar useCheckout = function useCheckout() {\n    // ensure it's in CheckoutProvider\n    useCheckoutSdkContextWithUseCase(\"calls useCheckout()\");\n    var ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CheckoutContext);\n    if (!ctx) {\n        throw new Error(\"Could not find Checkout Context; You need to wrap the part of your app that calls useCheckout() in an <CheckoutProvider> provider.\");\n    }\n    return ctx;\n};\nvar _excluded = [\n    \"mode\"\n];\nvar capitalized = function capitalized(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n};\nvar createElementComponent = function createElementComponent(type, isServer) {\n    var displayName = \"\".concat(capitalized(type), \"Element\");\n    var ClientElement = function ClientElement(_ref) {\n        var id = _ref.id, className = _ref.className, _ref$options = _ref.options, options = _ref$options === void 0 ? {} : _ref$options, onBlur = _ref.onBlur, onFocus = _ref.onFocus, onReady = _ref.onReady, onChange = _ref.onChange, onEscape = _ref.onEscape, onClick = _ref.onClick, onLoadError = _ref.onLoadError, onLoaderStart = _ref.onLoaderStart, onNetworksChange = _ref.onNetworksChange, onConfirm = _ref.onConfirm, onCancel = _ref.onCancel, onShippingAddressChange = _ref.onShippingAddressChange, onShippingRateChange = _ref.onShippingRateChange;\n        var ctx = useElementsOrCheckoutSdkContextWithUseCase(\"mounts <\".concat(displayName, \">\"));\n        var elements = \"elements\" in ctx ? ctx.elements : null;\n        var checkoutSdk = \"checkoutSdk\" in ctx ? ctx.checkoutSdk : null;\n        var _React$useState = react__WEBPACK_IMPORTED_MODULE_0__.useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), element = _React$useState2[0], setElement = _React$useState2[1];\n        var elementRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n        var domNode = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null); // For every event where the merchant provides a callback, call element.on\n        // with that callback. If the merchant ever changes the callback, removes\n        // the old callback with element.off and then call element.on with the new one.\n        useAttachEvent(element, \"blur\", onBlur);\n        useAttachEvent(element, \"focus\", onFocus);\n        useAttachEvent(element, \"escape\", onEscape);\n        useAttachEvent(element, \"click\", onClick);\n        useAttachEvent(element, \"loaderror\", onLoadError);\n        useAttachEvent(element, \"loaderstart\", onLoaderStart);\n        useAttachEvent(element, \"networkschange\", onNetworksChange);\n        useAttachEvent(element, \"confirm\", onConfirm);\n        useAttachEvent(element, \"cancel\", onCancel);\n        useAttachEvent(element, \"shippingaddresschange\", onShippingAddressChange);\n        useAttachEvent(element, \"shippingratechange\", onShippingRateChange);\n        useAttachEvent(element, \"change\", onChange);\n        var readyCallback;\n        if (onReady) {\n            if (type === \"expressCheckout\") {\n                // Passes through the event, which includes visible PM types\n                readyCallback = onReady;\n            } else {\n                // For other Elements, pass through the Element itself.\n                readyCallback = function readyCallback() {\n                    onReady(element);\n                };\n            }\n        }\n        useAttachEvent(element, \"ready\", readyCallback);\n        react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(function() {\n            if (elementRef.current === null && domNode.current !== null && (elements || checkoutSdk)) {\n                var newElement = null;\n                if (checkoutSdk) {\n                    switch(type){\n                        case \"payment\":\n                            newElement = checkoutSdk.createPaymentElement(options);\n                            break;\n                        case \"address\":\n                            if (\"mode\" in options) {\n                                var mode = options.mode, restOptions = _objectWithoutProperties(options, _excluded);\n                                if (mode === \"shipping\") {\n                                    newElement = checkoutSdk.createShippingAddressElement(restOptions);\n                                } else if (mode === \"billing\") {\n                                    newElement = checkoutSdk.createBillingAddressElement(restOptions);\n                                } else {\n                                    throw new Error(\"Invalid options.mode. mode must be 'billing' or 'shipping'.\");\n                                }\n                            } else {\n                                throw new Error(\"You must supply options.mode. mode must be 'billing' or 'shipping'.\");\n                            }\n                            break;\n                        case \"expressCheckout\":\n                            newElement = checkoutSdk.createExpressCheckoutElement(options);\n                            break;\n                        case \"currencySelector\":\n                            newElement = checkoutSdk.createCurrencySelectorElement();\n                            break;\n                        default:\n                            throw new Error(\"Invalid Element type \".concat(displayName, \". You must use either the <PaymentElement />, <AddressElement options={{mode: 'shipping'}} />, <AddressElement options={{mode: 'billing'}} />, or <ExpressCheckoutElement />.\"));\n                    }\n                } else if (elements) {\n                    newElement = elements.create(type, options);\n                } // Store element in a ref to ensure it's _immediately_ available in cleanup hooks in StrictMode\n                elementRef.current = newElement; // Store element in state to facilitate event listener attachment\n                setElement(newElement);\n                if (newElement) {\n                    newElement.mount(domNode.current);\n                }\n            }\n        }, [\n            elements,\n            checkoutSdk,\n            options\n        ]);\n        var prevOptions = usePrevious(options);\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n            if (!elementRef.current) {\n                return;\n            }\n            var updates = extractAllowedOptionsUpdates(options, prevOptions, [\n                \"paymentRequest\"\n            ]);\n            if (updates && \"update\" in elementRef.current) {\n                elementRef.current.update(updates);\n            }\n        }, [\n            options,\n            prevOptions\n        ]);\n        react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(function() {\n            return function() {\n                if (elementRef.current && typeof elementRef.current.destroy === \"function\") {\n                    try {\n                        elementRef.current.destroy();\n                        elementRef.current = null;\n                    } catch (error) {}\n                }\n            };\n        }, []);\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n            id: id,\n            className: className,\n            ref: domNode\n        });\n    }; // Only render the Element wrapper in a server environment.\n    var ServerElement = function ServerElement(props) {\n        useElementsOrCheckoutSdkContextWithUseCase(\"mounts <\".concat(displayName, \">\"));\n        var id = props.id, className = props.className;\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n            id: id,\n            className: className\n        });\n    };\n    var Element = isServer ? ServerElement : ClientElement;\n    Element.propTypes = {\n        id: prop_types__WEBPACK_IMPORTED_MODULE_1__.string,\n        className: prop_types__WEBPACK_IMPORTED_MODULE_1__.string,\n        onChange: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onBlur: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onFocus: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onReady: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onEscape: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onClick: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onLoadError: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onLoaderStart: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onNetworksChange: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onConfirm: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onCancel: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onShippingAddressChange: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onShippingRateChange: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        options: prop_types__WEBPACK_IMPORTED_MODULE_1__.object\n    };\n    Element.displayName = displayName;\n    Element.__elementType = type;\n    return Element;\n};\nvar isServer = \"undefined\" === \"undefined\";\nvar EmbeddedCheckoutContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nEmbeddedCheckoutContext.displayName = \"EmbeddedCheckoutProviderContext\";\nvar useEmbeddedCheckoutContext = function useEmbeddedCheckoutContext() {\n    var ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(EmbeddedCheckoutContext);\n    if (!ctx) {\n        throw new Error(\"<EmbeddedCheckout> must be used within <EmbeddedCheckoutProvider>\");\n    }\n    return ctx;\n};\nvar INVALID_STRIPE_ERROR = \"Invalid prop `stripe` supplied to `EmbeddedCheckoutProvider`. We recommend using the `loadStripe` utility from `@stripe/stripe-js`. See https://stripe.com/docs/stripe-js/react#elements-props-stripe for details.\";\nvar EmbeddedCheckoutProvider = function EmbeddedCheckoutProvider(_ref) {\n    var rawStripeProp = _ref.stripe, options = _ref.options, children = _ref.children;\n    var parsed = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function() {\n        return parseStripeProp(rawStripeProp, INVALID_STRIPE_ERROR);\n    }, [\n        rawStripeProp\n    ]);\n    var embeddedCheckoutPromise = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    var loadedStripe = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    var _React$useState = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        embeddedCheckout: null\n    }), _React$useState2 = _slicedToArray(_React$useState, 2), ctx = _React$useState2[0], setContext = _React$useState2[1];\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        // Don't support any ctx updates once embeddedCheckout or stripe is set.\n        if (loadedStripe.current || embeddedCheckoutPromise.current) {\n            return;\n        }\n        var setStripeAndInitEmbeddedCheckout = function setStripeAndInitEmbeddedCheckout(stripe) {\n            if (loadedStripe.current || embeddedCheckoutPromise.current) return;\n            loadedStripe.current = stripe;\n            embeddedCheckoutPromise.current = loadedStripe.current.initEmbeddedCheckout(options).then(function(embeddedCheckout) {\n                setContext({\n                    embeddedCheckout: embeddedCheckout\n                });\n            });\n        }; // For an async stripePromise, store it once resolved\n        if (parsed.tag === \"async\" && !loadedStripe.current && (options.clientSecret || options.fetchClientSecret)) {\n            parsed.stripePromise.then(function(stripe) {\n                if (stripe) {\n                    setStripeAndInitEmbeddedCheckout(stripe);\n                }\n            });\n        } else if (parsed.tag === \"sync\" && !loadedStripe.current && (options.clientSecret || options.fetchClientSecret)) {\n            // Or, handle a sync stripe instance going from null -> populated\n            setStripeAndInitEmbeddedCheckout(parsed.stripe);\n        }\n    }, [\n        parsed,\n        options,\n        ctx,\n        loadedStripe\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        // cleanup on unmount\n        return function() {\n            // If embedded checkout is fully initialized, destroy it.\n            if (ctx.embeddedCheckout) {\n                embeddedCheckoutPromise.current = null;\n                ctx.embeddedCheckout.destroy();\n            } else if (embeddedCheckoutPromise.current) {\n                // If embedded checkout is still initializing, destroy it once\n                // it's done. This could be caused by unmounting very quickly\n                // after mounting.\n                embeddedCheckoutPromise.current.then(function() {\n                    embeddedCheckoutPromise.current = null;\n                    if (ctx.embeddedCheckout) {\n                        ctx.embeddedCheckout.destroy();\n                    }\n                });\n            }\n        };\n    }, [\n        ctx.embeddedCheckout\n    ]); // Attach react-stripe-js version to stripe.js instance\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        registerWithStripeJs(loadedStripe);\n    }, [\n        loadedStripe\n    ]); // Warn on changes to stripe prop.\n    // The stripe prop value can only go from null to non-null once and\n    // can't be changed after that.\n    var prevStripe = usePrevious(rawStripeProp);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        if (prevStripe !== null && prevStripe !== rawStripeProp) {\n            console.warn(\"Unsupported prop change on EmbeddedCheckoutProvider: You cannot change the `stripe` prop after setting it.\");\n        }\n    }, [\n        prevStripe,\n        rawStripeProp\n    ]); // Warn on changes to options.\n    var prevOptions = usePrevious(options);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        if (prevOptions == null) {\n            return;\n        }\n        if (options == null) {\n            console.warn(\"Unsupported prop change on EmbeddedCheckoutProvider: You cannot unset options after setting them.\");\n            return;\n        }\n        if (options.clientSecret === undefined && options.fetchClientSecret === undefined) {\n            console.warn(\"Invalid props passed to EmbeddedCheckoutProvider: You must provide one of either `options.fetchClientSecret` or `options.clientSecret`.\");\n        }\n        if (prevOptions.clientSecret != null && options.clientSecret !== prevOptions.clientSecret) {\n            console.warn(\"Unsupported prop change on EmbeddedCheckoutProvider: You cannot change the client secret after setting it. Unmount and create a new instance of EmbeddedCheckoutProvider instead.\");\n        }\n        if (prevOptions.fetchClientSecret != null && options.fetchClientSecret !== prevOptions.fetchClientSecret) {\n            console.warn(\"Unsupported prop change on EmbeddedCheckoutProvider: You cannot change fetchClientSecret after setting it. Unmount and create a new instance of EmbeddedCheckoutProvider instead.\");\n        }\n        if (prevOptions.onComplete != null && options.onComplete !== prevOptions.onComplete) {\n            console.warn(\"Unsupported prop change on EmbeddedCheckoutProvider: You cannot change the onComplete option after setting it.\");\n        }\n        if (prevOptions.onShippingDetailsChange != null && options.onShippingDetailsChange !== prevOptions.onShippingDetailsChange) {\n            console.warn(\"Unsupported prop change on EmbeddedCheckoutProvider: You cannot change the onShippingDetailsChange option after setting it.\");\n        }\n        if (prevOptions.onLineItemsChange != null && options.onLineItemsChange !== prevOptions.onLineItemsChange) {\n            console.warn(\"Unsupported prop change on EmbeddedCheckoutProvider: You cannot change the onLineItemsChange option after setting it.\");\n        }\n    }, [\n        prevOptions,\n        options\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(EmbeddedCheckoutContext.Provider, {\n        value: ctx\n    }, children);\n};\nvar EmbeddedCheckoutClientElement = function EmbeddedCheckoutClientElement(_ref) {\n    var id = _ref.id, className = _ref.className;\n    var _useEmbeddedCheckoutC = useEmbeddedCheckoutContext(), embeddedCheckout = _useEmbeddedCheckoutC.embeddedCheckout;\n    var isMounted = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    var domNode = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(function() {\n        if (!isMounted.current && embeddedCheckout && domNode.current !== null) {\n            embeddedCheckout.mount(domNode.current);\n            isMounted.current = true;\n        } // Clean up on unmount\n        return function() {\n            if (isMounted.current && embeddedCheckout) {\n                try {\n                    embeddedCheckout.unmount();\n                    isMounted.current = false;\n                } catch (e) {\n                // Parent effects are destroyed before child effects, so\n                // in cases where both the EmbeddedCheckoutProvider and\n                // the EmbeddedCheckout component are removed at the same\n                // time, the embeddedCheckout instance will be destroyed,\n                // which causes an error when calling unmount.\n                }\n            }\n        };\n    }, [\n        embeddedCheckout\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        ref: domNode,\n        id: id,\n        className: className\n    });\n}; // Only render the wrapper in a server environment.\nvar EmbeddedCheckoutServerElement = function EmbeddedCheckoutServerElement(_ref2) {\n    var id = _ref2.id, className = _ref2.className;\n    // Validate that we are in the right context by calling useEmbeddedCheckoutContext.\n    useEmbeddedCheckoutContext();\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        id: id,\n        className: className\n    });\n};\nvar EmbeddedCheckout = isServer ? EmbeddedCheckoutServerElement : EmbeddedCheckoutClientElement;\n/**\n * @docs https://stripe.com/docs/stripe-js/react#usestripe-hook\n */ var useStripe = function useStripe() {\n    var _useElementsOrCheckou = useElementsOrCheckoutSdkContextWithUseCase(\"calls useStripe()\"), stripe = _useElementsOrCheckou.stripe;\n    return stripe;\n};\n/**\n * Requires beta access:\n * Contact [Stripe support](https://support.stripe.com/) for more information.\n *\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var AuBankAccountElement = createElementComponent(\"auBankAccount\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var CardElement = createElementComponent(\"card\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var CardNumberElement = createElementComponent(\"cardNumber\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var CardExpiryElement = createElementComponent(\"cardExpiry\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var CardCvcElement = createElementComponent(\"cardCvc\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var FpxBankElement = createElementComponent(\"fpxBank\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var IbanElement = createElementComponent(\"iban\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var IdealBankElement = createElementComponent(\"idealBank\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var P24BankElement = createElementComponent(\"p24Bank\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var EpsBankElement = createElementComponent(\"epsBank\", isServer);\nvar PaymentElement = createElementComponent(\"payment\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var ExpressCheckoutElement = createElementComponent(\"expressCheckout\", isServer);\n/**\n * Requires beta access:\n * Contact [Stripe support](https://support.stripe.com/) for more information.\n */ var CurrencySelectorElement = createElementComponent(\"currencySelector\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var PaymentRequestButtonElement = createElementComponent(\"paymentRequestButton\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var LinkAuthenticationElement = createElementComponent(\"linkAuthentication\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var AddressElement = createElementComponent(\"address\", isServer);\n/**\n * @deprecated\n * Use `AddressElement` instead.\n *\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var ShippingAddressElement = createElementComponent(\"shippingAddress\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var PaymentMethodMessagingElement = createElementComponent(\"paymentMethodMessaging\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var AffirmMessageElement = createElementComponent(\"affirmMessage\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var AfterpayClearpayMessageElement = createElementComponent(\"afterpayClearpayMessage\", isServer);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN0cmlwZS9yZWFjdC1zdHJpcGUtanMvZGlzdC9yZWFjdC1zdHJpcGUuZXNtLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMEI7QUFDUztBQUVuQyxTQUFTRSxRQUFRQyxNQUFNLEVBQUVDLGNBQWM7SUFDckMsSUFBSUMsT0FBT0MsT0FBT0QsSUFBSSxDQUFDRjtJQUV2QixJQUFJRyxPQUFPQyxxQkFBcUIsRUFBRTtRQUNoQyxJQUFJQyxVQUFVRixPQUFPQyxxQkFBcUIsQ0FBQ0o7UUFFM0MsSUFBSUMsZ0JBQWdCO1lBQ2xCSSxVQUFVQSxRQUFRQyxNQUFNLENBQUMsU0FBVUMsR0FBRztnQkFDcEMsT0FBT0osT0FBT0ssd0JBQXdCLENBQUNSLFFBQVFPLEtBQUtFLFVBQVU7WUFDaEU7UUFDRjtRQUVBUCxLQUFLUSxJQUFJLENBQUNDLEtBQUssQ0FBQ1QsTUFBTUc7SUFDeEI7SUFFQSxPQUFPSDtBQUNUO0FBRUEsU0FBU1UsZUFBZUMsTUFBTTtJQUM1QixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUMsVUFBVUMsTUFBTSxFQUFFRixJQUFLO1FBQ3pDLElBQUlHLFNBQVNGLFNBQVMsQ0FBQ0QsRUFBRSxJQUFJLE9BQU9DLFNBQVMsQ0FBQ0QsRUFBRSxHQUFHLENBQUM7UUFFcEQsSUFBSUEsSUFBSSxHQUFHO1lBQ1RmLFFBQVFJLE9BQU9jLFNBQVMsTUFBTUMsT0FBTyxDQUFDLFNBQVVDLEdBQUc7Z0JBQ2pEQyxnQkFBZ0JQLFFBQVFNLEtBQUtGLE1BQU0sQ0FBQ0UsSUFBSTtZQUMxQztRQUNGLE9BQU8sSUFBSWhCLE9BQU9rQix5QkFBeUIsRUFBRTtZQUMzQ2xCLE9BQU9tQixnQkFBZ0IsQ0FBQ1QsUUFBUVYsT0FBT2tCLHlCQUF5QixDQUFDSjtRQUNuRSxPQUFPO1lBQ0xsQixRQUFRSSxPQUFPYyxTQUFTQyxPQUFPLENBQUMsU0FBVUMsR0FBRztnQkFDM0NoQixPQUFPb0Is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L2ltZ3RvdmlkZW8vLi9ub2RlX21vZHVsZXMvQHN0cmlwZS9yZWFjdC1zdHJpcGUtanMvZGlzdC9yZWFjdC1zdHJpcGUuZXNtLm1qcz9hMTUyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG5cbiAgICBpZiAoZW51bWVyYWJsZU9ubHkpIHtcbiAgICAgIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuXG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuXG4gIHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTtcblxuICB2YXIga2V5LCBpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTtcbiAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xufVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gIHZhciBfaSA9IGFyciAmJiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBhcnJbU3ltYm9sLml0ZXJhdG9yXSB8fCBhcnJbXCJAQGl0ZXJhdG9yXCJdKTtcblxuICBpZiAoX2kgPT0gbnVsbCkgcmV0dXJuO1xuICB2YXIgX2FyciA9IFtdO1xuICB2YXIgX24gPSB0cnVlO1xuICB2YXIgX2QgPSBmYWxzZTtcblxuICB2YXIgX3MsIF9lO1xuXG4gIHRyeSB7XG4gICAgZm9yIChfaSA9IF9pLmNhbGwoYXJyKTsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2QgPSB0cnVlO1xuICAgIF9lID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9hcnI7XG59XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gIHJldHVybiBhcnIyO1xufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG52YXIgdXNlQXR0YWNoRXZlbnQgPSBmdW5jdGlvbiB1c2VBdHRhY2hFdmVudChlbGVtZW50LCBldmVudCwgY2IpIHtcbiAgdmFyIGNiRGVmaW5lZCA9ICEhY2I7XG4gIHZhciBjYlJlZiA9IFJlYWN0LnVzZVJlZihjYik7IC8vIEluIG1hbnkgaW50ZWdyYXRpb25zIHRoZSBjYWxsYmFjayBwcm9wIGNoYW5nZXMgb24gZWFjaCByZW5kZXIuXG4gIC8vIFVzaW5nIGEgcmVmIHNhdmVzIHVzIGZyb20gY2FsbGluZyBlbGVtZW50Lm9uLy5vZmYgZXZlcnkgcmVuZGVyLlxuXG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgY2JSZWYuY3VycmVudCA9IGNiO1xuICB9LCBbY2JdKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWNiRGVmaW5lZCB8fCAhZWxlbWVudCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHt9O1xuICAgIH1cblxuICAgIHZhciBkZWNvcmF0ZWRDYiA9IGZ1bmN0aW9uIGRlY29yYXRlZENiKCkge1xuICAgICAgaWYgKGNiUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY2JSZWYuY3VycmVudC5hcHBseShjYlJlZiwgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZWxlbWVudC5vbihldmVudCwgZGVjb3JhdGVkQ2IpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBlbGVtZW50Lm9mZihldmVudCwgZGVjb3JhdGVkQ2IpO1xuICAgIH07XG4gIH0sIFtjYkRlZmluZWQsIGV2ZW50LCBlbGVtZW50LCBjYlJlZl0pO1xufTtcblxudmFyIHVzZVByZXZpb3VzID0gZnVuY3Rpb24gdXNlUHJldmlvdXModmFsdWUpIHtcbiAgdmFyIHJlZiA9IFJlYWN0LnVzZVJlZih2YWx1ZSk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgfSwgW3ZhbHVlXSk7XG4gIHJldHVybiByZWYuY3VycmVudDtcbn07XG5cbnZhciBpc1Vua25vd25PYmplY3QgPSBmdW5jdGlvbiBpc1Vua25vd25PYmplY3QocmF3KSB7XG4gIHJldHVybiByYXcgIT09IG51bGwgJiYgX3R5cGVvZihyYXcpID09PSAnb2JqZWN0Jztcbn07XG52YXIgaXNQcm9taXNlID0gZnVuY3Rpb24gaXNQcm9taXNlKHJhdykge1xuICByZXR1cm4gaXNVbmtub3duT2JqZWN0KHJhdykgJiYgdHlwZW9mIHJhdy50aGVuID09PSAnZnVuY3Rpb24nO1xufTsgLy8gV2UgYXJlIHVzaW5nIHR5cGVzIHRvIGVuZm9yY2UgdGhlIGBzdHJpcGVgIHByb3AgaW4gdGhpcyBsaWIsXG4vLyBidXQgaW4gYW4gdW50eXBlZCBpbnRlZ3JhdGlvbiBgc3RyaXBlYCBjb3VsZCBiZSBhbnl0aGluZywgc28gd2UgbmVlZFxuLy8gdG8gZG8gc29tZSBzYW5pdHkgdmFsaWRhdGlvbiB0byBwcmV2ZW50IHR5cGUgZXJyb3JzLlxuXG52YXIgaXNTdHJpcGUgPSBmdW5jdGlvbiBpc1N0cmlwZShyYXcpIHtcbiAgcmV0dXJuIGlzVW5rbm93bk9iamVjdChyYXcpICYmIHR5cGVvZiByYXcuZWxlbWVudHMgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHJhdy5jcmVhdGVUb2tlbiA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcmF3LmNyZWF0ZVBheW1lbnRNZXRob2QgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHJhdy5jb25maXJtQ2FyZFBheW1lbnQgPT09ICdmdW5jdGlvbic7XG59O1xuXG52YXIgUExBSU5fT0JKRUNUX1NUUiA9ICdbb2JqZWN0IE9iamVjdF0nO1xudmFyIGlzRXF1YWwgPSBmdW5jdGlvbiBpc0VxdWFsKGxlZnQsIHJpZ2h0KSB7XG4gIGlmICghaXNVbmtub3duT2JqZWN0KGxlZnQpIHx8ICFpc1Vua25vd25PYmplY3QocmlnaHQpKSB7XG4gICAgcmV0dXJuIGxlZnQgPT09IHJpZ2h0O1xuICB9XG5cbiAgdmFyIGxlZnRBcnJheSA9IEFycmF5LmlzQXJyYXkobGVmdCk7XG4gIHZhciByaWdodEFycmF5ID0gQXJyYXkuaXNBcnJheShyaWdodCk7XG4gIGlmIChsZWZ0QXJyYXkgIT09IHJpZ2h0QXJyYXkpIHJldHVybiBmYWxzZTtcbiAgdmFyIGxlZnRQbGFpbk9iamVjdCA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChsZWZ0KSA9PT0gUExBSU5fT0JKRUNUX1NUUjtcbiAgdmFyIHJpZ2h0UGxhaW5PYmplY3QgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocmlnaHQpID09PSBQTEFJTl9PQkpFQ1RfU1RSO1xuICBpZiAobGVmdFBsYWluT2JqZWN0ICE9PSByaWdodFBsYWluT2JqZWN0KSByZXR1cm4gZmFsc2U7IC8vIG5vdCBzdXJlIHdoYXQgc29ydCBvZiBzcGVjaWFsIG9iamVjdCB0aGlzIGlzIChyZWdleHAgaXMgb25lIG9wdGlvbiksIHNvXG4gIC8vIGZhbGxiYWNrIHRvIHJlZmVyZW5jZSBjaGVjay5cblxuICBpZiAoIWxlZnRQbGFpbk9iamVjdCAmJiAhbGVmdEFycmF5KSByZXR1cm4gbGVmdCA9PT0gcmlnaHQ7XG4gIHZhciBsZWZ0S2V5cyA9IE9iamVjdC5rZXlzKGxlZnQpO1xuICB2YXIgcmlnaHRLZXlzID0gT2JqZWN0LmtleXMocmlnaHQpO1xuICBpZiAobGVmdEtleXMubGVuZ3RoICE9PSByaWdodEtleXMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIHZhciBrZXlTZXQgPSB7fTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlZnRLZXlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAga2V5U2V0W2xlZnRLZXlzW2ldXSA9IHRydWU7XG4gIH1cblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgcmlnaHRLZXlzLmxlbmd0aDsgX2kgKz0gMSkge1xuICAgIGtleVNldFtyaWdodEtleXNbX2ldXSA9IHRydWU7XG4gIH1cblxuICB2YXIgYWxsS2V5cyA9IE9iamVjdC5rZXlzKGtleVNldCk7XG5cbiAgaWYgKGFsbEtleXMubGVuZ3RoICE9PSBsZWZ0S2V5cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgbCA9IGxlZnQ7XG4gIHZhciByID0gcmlnaHQ7XG5cbiAgdmFyIHByZWQgPSBmdW5jdGlvbiBwcmVkKGtleSkge1xuICAgIHJldHVybiBpc0VxdWFsKGxba2V5XSwgcltrZXldKTtcbiAgfTtcblxuICByZXR1cm4gYWxsS2V5cy5ldmVyeShwcmVkKTtcbn07XG5cbnZhciBleHRyYWN0QWxsb3dlZE9wdGlvbnNVcGRhdGVzID0gZnVuY3Rpb24gZXh0cmFjdEFsbG93ZWRPcHRpb25zVXBkYXRlcyhvcHRpb25zLCBwcmV2T3B0aW9ucywgaW1tdXRhYmxlS2V5cykge1xuICBpZiAoIWlzVW5rbm93bk9iamVjdChvcHRpb25zKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9wdGlvbnMpLnJlZHVjZShmdW5jdGlvbiAobmV3T3B0aW9ucywga2V5KSB7XG4gICAgdmFyIGlzVXBkYXRlZCA9ICFpc1Vua25vd25PYmplY3QocHJldk9wdGlvbnMpIHx8ICFpc0VxdWFsKG9wdGlvbnNba2V5XSwgcHJldk9wdGlvbnNba2V5XSk7XG5cbiAgICBpZiAoaW1tdXRhYmxlS2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICBpZiAoaXNVcGRhdGVkKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlVuc3VwcG9ydGVkIHByb3AgY2hhbmdlOiBvcHRpb25zLlwiLmNvbmNhdChrZXksIFwiIGlzIG5vdCBhIG11dGFibGUgcHJvcGVydHkuXCIpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld09wdGlvbnM7XG4gICAgfVxuXG4gICAgaWYgKCFpc1VwZGF0ZWQpIHtcbiAgICAgIHJldHVybiBuZXdPcHRpb25zO1xuICAgIH1cblxuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgbmV3T3B0aW9ucyB8fCB7fSksIHt9LCBfZGVmaW5lUHJvcGVydHkoe30sIGtleSwgb3B0aW9uc1trZXldKSk7XG4gIH0sIG51bGwpO1xufTtcblxudmFyIElOVkFMSURfU1RSSVBFX0VSUk9SJDIgPSAnSW52YWxpZCBwcm9wIGBzdHJpcGVgIHN1cHBsaWVkIHRvIGBFbGVtZW50c2AuIFdlIHJlY29tbWVuZCB1c2luZyB0aGUgYGxvYWRTdHJpcGVgIHV0aWxpdHkgZnJvbSBgQHN0cmlwZS9zdHJpcGUtanNgLiBTZWUgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnRzLXByb3BzLXN0cmlwZSBmb3IgZGV0YWlscy4nOyAvLyBXZSBhcmUgdXNpbmcgdHlwZXMgdG8gZW5mb3JjZSB0aGUgYHN0cmlwZWAgcHJvcCBpbiB0aGlzIGxpYiwgYnV0IGluIGEgcmVhbFxuLy8gaW50ZWdyYXRpb24gYHN0cmlwZWAgY291bGQgYmUgYW55dGhpbmcsIHNvIHdlIG5lZWQgdG8gZG8gc29tZSBzYW5pdHlcbi8vIHZhbGlkYXRpb24gdG8gcHJldmVudCB0eXBlIGVycm9ycy5cblxudmFyIHZhbGlkYXRlU3RyaXBlID0gZnVuY3Rpb24gdmFsaWRhdGVTdHJpcGUobWF5YmVTdHJpcGUpIHtcbiAgdmFyIGVycm9yTXNnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBJTlZBTElEX1NUUklQRV9FUlJPUiQyO1xuXG4gIGlmIChtYXliZVN0cmlwZSA9PT0gbnVsbCB8fCBpc1N0cmlwZShtYXliZVN0cmlwZSkpIHtcbiAgICByZXR1cm4gbWF5YmVTdHJpcGU7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNc2cpO1xufTtcblxudmFyIHBhcnNlU3RyaXBlUHJvcCA9IGZ1bmN0aW9uIHBhcnNlU3RyaXBlUHJvcChyYXcpIHtcbiAgdmFyIGVycm9yTXNnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBJTlZBTElEX1NUUklQRV9FUlJPUiQyO1xuXG4gIGlmIChpc1Byb21pc2UocmF3KSkge1xuICAgIHJldHVybiB7XG4gICAgICB0YWc6ICdhc3luYycsXG4gICAgICBzdHJpcGVQcm9taXNlOiBQcm9taXNlLnJlc29sdmUocmF3KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlU3RyaXBlKHJlc3VsdCwgZXJyb3JNc2cpO1xuICAgICAgfSlcbiAgICB9O1xuICB9XG5cbiAgdmFyIHN0cmlwZSA9IHZhbGlkYXRlU3RyaXBlKHJhdywgZXJyb3JNc2cpO1xuXG4gIGlmIChzdHJpcGUgPT09IG51bGwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGFnOiAnZW1wdHknXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdGFnOiAnc3luYycsXG4gICAgc3RyaXBlOiBzdHJpcGVcbiAgfTtcbn07XG5cbnZhciByZWdpc3RlcldpdGhTdHJpcGVKcyA9IGZ1bmN0aW9uIHJlZ2lzdGVyV2l0aFN0cmlwZUpzKHN0cmlwZSkge1xuICBpZiAoIXN0cmlwZSB8fCAhc3RyaXBlLl9yZWdpc3RlcldyYXBwZXIgfHwgIXN0cmlwZS5yZWdpc3RlckFwcEluZm8pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBzdHJpcGUuX3JlZ2lzdGVyV3JhcHBlcih7XG4gICAgbmFtZTogJ3JlYWN0LXN0cmlwZS1qcycsXG4gICAgdmVyc2lvbjogXCIzLjYuMFwiXG4gIH0pO1xuXG4gIHN0cmlwZS5yZWdpc3RlckFwcEluZm8oe1xuICAgIG5hbWU6ICdyZWFjdC1zdHJpcGUtanMnLFxuICAgIHZlcnNpb246IFwiMy42LjBcIixcbiAgICB1cmw6ICdodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QnXG4gIH0pO1xufTtcblxudmFyIEVsZW1lbnRzQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuRWxlbWVudHNDb250ZXh0LmRpc3BsYXlOYW1lID0gJ0VsZW1lbnRzQ29udGV4dCc7XG52YXIgcGFyc2VFbGVtZW50c0NvbnRleHQgPSBmdW5jdGlvbiBwYXJzZUVsZW1lbnRzQ29udGV4dChjdHgsIHVzZUNhc2UpIHtcbiAgaWYgKCFjdHgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBFbGVtZW50cyBjb250ZXh0OyBZb3UgbmVlZCB0byB3cmFwIHRoZSBwYXJ0IG9mIHlvdXIgYXBwIHRoYXQgXCIuY29uY2F0KHVzZUNhc2UsIFwiIGluIGFuIDxFbGVtZW50cz4gcHJvdmlkZXIuXCIpKTtcbiAgfVxuXG4gIHJldHVybiBjdHg7XG59O1xuLyoqXG4gKiBUaGUgYEVsZW1lbnRzYCBwcm92aWRlciBhbGxvd3MgeW91IHRvIHVzZSBbRWxlbWVudCBjb21wb25lbnRzXShodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzKSBhbmQgYWNjZXNzIHRoZSBbU3RyaXBlIG9iamVjdF0oaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3MvanMvaW5pdGlhbGl6aW5nKSBpbiBhbnkgbmVzdGVkIGNvbXBvbmVudC5cbiAqIFJlbmRlciBhbiBgRWxlbWVudHNgIHByb3ZpZGVyIGF0IHRoZSByb290IG9mIHlvdXIgUmVhY3QgYXBwIHNvIHRoYXQgaXQgaXMgYXZhaWxhYmxlIGV2ZXJ5d2hlcmUgeW91IG5lZWQgaXQuXG4gKlxuICogVG8gdXNlIHRoZSBgRWxlbWVudHNgIHByb3ZpZGVyLCBjYWxsIGBsb2FkU3RyaXBlYCBmcm9tIGBAc3RyaXBlL3N0cmlwZS1qc2Agd2l0aCB5b3VyIHB1Ymxpc2hhYmxlIGtleS5cbiAqIFRoZSBgbG9hZFN0cmlwZWAgZnVuY3Rpb24gd2lsbCBhc3luY2hyb25vdXNseSBsb2FkIHRoZSBTdHJpcGUuanMgc2NyaXB0IGFuZCBpbml0aWFsaXplIGEgYFN0cmlwZWAgb2JqZWN0LlxuICogUGFzcyB0aGUgcmV0dXJuZWQgYFByb21pc2VgIHRvIGBFbGVtZW50c2AuXG4gKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnRzLXByb3ZpZGVyXG4gKi9cblxudmFyIEVsZW1lbnRzID0gZnVuY3Rpb24gRWxlbWVudHMoX3JlZikge1xuICB2YXIgcmF3U3RyaXBlUHJvcCA9IF9yZWYuc3RyaXBlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucyxcbiAgICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbjtcbiAgdmFyIHBhcnNlZCA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwYXJzZVN0cmlwZVByb3AocmF3U3RyaXBlUHJvcCk7XG4gIH0sIFtyYXdTdHJpcGVQcm9wXSk7IC8vIEZvciBhIHN5bmMgc3RyaXBlIGluc3RhbmNlLCBpbml0aWFsaXplIGludG8gY29udGV4dFxuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGUgPSBSZWFjdC51c2VTdGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0cmlwZTogcGFyc2VkLnRhZyA9PT0gJ3N5bmMnID8gcGFyc2VkLnN0cmlwZSA6IG51bGwsXG4gICAgICBlbGVtZW50czogcGFyc2VkLnRhZyA9PT0gJ3N5bmMnID8gcGFyc2VkLnN0cmlwZS5lbGVtZW50cyhvcHRpb25zKSA6IG51bGxcbiAgICB9O1xuICB9KSxcbiAgICAgIF9SZWFjdCR1c2VTdGF0ZTIgPSBfc2xpY2VkVG9BcnJheShfUmVhY3QkdXNlU3RhdGUsIDIpLFxuICAgICAgY3R4ID0gX1JlYWN0JHVzZVN0YXRlMlswXSxcbiAgICAgIHNldENvbnRleHQgPSBfUmVhY3QkdXNlU3RhdGUyWzFdO1xuXG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGlzTW91bnRlZCA9IHRydWU7XG5cbiAgICB2YXIgc2FmZVNldENvbnRleHQgPSBmdW5jdGlvbiBzYWZlU2V0Q29udGV4dChzdHJpcGUpIHtcbiAgICAgIHNldENvbnRleHQoZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAvLyBuby1vcCBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBzdHJpcGUgaW5zdGFuY2UgKGh0dHBzOi8vZ2l0aHViLmNvbS9zdHJpcGUvcmVhY3Qtc3RyaXBlLWpzL2lzc3Vlcy8yOTYpXG4gICAgICAgIGlmIChjdHguc3RyaXBlKSByZXR1cm4gY3R4O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0cmlwZTogc3RyaXBlLFxuICAgICAgICAgIGVsZW1lbnRzOiBzdHJpcGUuZWxlbWVudHMob3B0aW9ucylcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH07IC8vIEZvciBhbiBhc3luYyBzdHJpcGVQcm9taXNlLCBzdG9yZSBpdCBpbiBjb250ZXh0IG9uY2UgcmVzb2x2ZWRcblxuXG4gICAgaWYgKHBhcnNlZC50YWcgPT09ICdhc3luYycgJiYgIWN0eC5zdHJpcGUpIHtcbiAgICAgIHBhcnNlZC5zdHJpcGVQcm9taXNlLnRoZW4oZnVuY3Rpb24gKHN0cmlwZSkge1xuICAgICAgICBpZiAoc3RyaXBlICYmIGlzTW91bnRlZCkge1xuICAgICAgICAgIC8vIE9ubHkgdXBkYXRlIEVsZW1lbnRzIGNvbnRleHQgaWYgdGhlIGNvbXBvbmVudCBpcyBzdGlsbCBtb3VudGVkXG4gICAgICAgICAgLy8gYW5kIHN0cmlwZSBpcyBub3QgbnVsbC4gV2UgYWxsb3cgc3RyaXBlIHRvIGJlIG51bGwgdG8gbWFrZVxuICAgICAgICAgIC8vIGhhbmRsaW5nIFNTUiBlYXNpZXIuXG4gICAgICAgICAgc2FmZVNldENvbnRleHQoc3RyaXBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChwYXJzZWQudGFnID09PSAnc3luYycgJiYgIWN0eC5zdHJpcGUpIHtcbiAgICAgIC8vIE9yLCBoYW5kbGUgYSBzeW5jIHN0cmlwZSBpbnN0YW5jZSBnb2luZyBmcm9tIG51bGwgLT4gcG9wdWxhdGVkXG4gICAgICBzYWZlU2V0Q29udGV4dChwYXJzZWQuc3RyaXBlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaXNNb3VudGVkID0gZmFsc2U7XG4gICAgfTtcbiAgfSwgW3BhcnNlZCwgY3R4LCBvcHRpb25zXSk7IC8vIFdhcm4gb24gY2hhbmdlcyB0byBzdHJpcGUgcHJvcFxuXG4gIHZhciBwcmV2U3RyaXBlID0gdXNlUHJldmlvdXMocmF3U3RyaXBlUHJvcCk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHByZXZTdHJpcGUgIT09IG51bGwgJiYgcHJldlN0cmlwZSAhPT0gcmF3U3RyaXBlUHJvcCkge1xuICAgICAgY29uc29sZS53YXJuKCdVbnN1cHBvcnRlZCBwcm9wIGNoYW5nZSBvbiBFbGVtZW50czogWW91IGNhbm5vdCBjaGFuZ2UgdGhlIGBzdHJpcGVgIHByb3AgYWZ0ZXIgc2V0dGluZyBpdC4nKTtcbiAgICB9XG4gIH0sIFtwcmV2U3RyaXBlLCByYXdTdHJpcGVQcm9wXSk7IC8vIEFwcGx5IHVwZGF0ZXMgdG8gZWxlbWVudHMgd2hlbiBvcHRpb25zIHByb3AgaGFzIHJlbGV2YW50IGNoYW5nZXNcblxuICB2YXIgcHJldk9wdGlvbnMgPSB1c2VQcmV2aW91cyhvcHRpb25zKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWN0eC5lbGVtZW50cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB1cGRhdGVzID0gZXh0cmFjdEFsbG93ZWRPcHRpb25zVXBkYXRlcyhvcHRpb25zLCBwcmV2T3B0aW9ucywgWydjbGllbnRTZWNyZXQnLCAnZm9udHMnXSk7XG5cbiAgICBpZiAodXBkYXRlcykge1xuICAgICAgY3R4LmVsZW1lbnRzLnVwZGF0ZSh1cGRhdGVzKTtcbiAgICB9XG4gIH0sIFtvcHRpb25zLCBwcmV2T3B0aW9ucywgY3R4LmVsZW1lbnRzXSk7IC8vIEF0dGFjaCByZWFjdC1zdHJpcGUtanMgdmVyc2lvbiB0byBzdHJpcGUuanMgaW5zdGFuY2VcblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJlZ2lzdGVyV2l0aFN0cmlwZUpzKGN0eC5zdHJpcGUpO1xuICB9LCBbY3R4LnN0cmlwZV0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRWxlbWVudHNDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGN0eFxuICB9LCBjaGlsZHJlbik7XG59O1xuRWxlbWVudHMucHJvcFR5cGVzID0ge1xuICBzdHJpcGU6IFByb3BUeXBlcy5hbnksXG4gIG9wdGlvbnM6IFByb3BUeXBlcy5vYmplY3Rcbn07XG52YXIgdXNlRWxlbWVudHNDb250ZXh0V2l0aFVzZUNhc2UgPSBmdW5jdGlvbiB1c2VFbGVtZW50c0NvbnRleHRXaXRoVXNlQ2FzZSh1c2VDYXNlTWVzc2FnZSkge1xuICB2YXIgY3R4ID0gUmVhY3QudXNlQ29udGV4dChFbGVtZW50c0NvbnRleHQpO1xuICByZXR1cm4gcGFyc2VFbGVtZW50c0NvbnRleHQoY3R4LCB1c2VDYXNlTWVzc2FnZSk7XG59O1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjdXNlZWxlbWVudHMtaG9va1xuICovXG5cbnZhciB1c2VFbGVtZW50cyA9IGZ1bmN0aW9uIHVzZUVsZW1lbnRzKCkge1xuICB2YXIgX3VzZUVsZW1lbnRzQ29udGV4dFdpID0gdXNlRWxlbWVudHNDb250ZXh0V2l0aFVzZUNhc2UoJ2NhbGxzIHVzZUVsZW1lbnRzKCknKSxcbiAgICAgIGVsZW1lbnRzID0gX3VzZUVsZW1lbnRzQ29udGV4dFdpLmVsZW1lbnRzO1xuXG4gIHJldHVybiBlbGVtZW50cztcbn07XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50cy1jb25zdW1lclxuICovXG5cbnZhciBFbGVtZW50c0NvbnN1bWVyID0gZnVuY3Rpb24gRWxlbWVudHNDb25zdW1lcihfcmVmMikge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmMi5jaGlsZHJlbjtcbiAgdmFyIGN0eCA9IHVzZUVsZW1lbnRzQ29udGV4dFdpdGhVc2VDYXNlKCdtb3VudHMgPEVsZW1lbnRzQ29uc3VtZXI+Jyk7IC8vIEFzc2VydCB0byBzYXRpc2Z5IHRoZSBidXN0ZWQgUmVhY3QuRkMgcmV0dXJuIHR5cGUgKGl0IHNob3VsZCBiZSBSZWFjdE5vZGUpXG5cbiAgcmV0dXJuIGNoaWxkcmVuKGN0eCk7XG59O1xuRWxlbWVudHNDb25zdW1lci5wcm9wVHlwZXMgPSB7XG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkXG59O1xuXG52YXIgX2V4Y2x1ZGVkJDEgPSBbXCJvblwiLCBcInNlc3Npb25cIl07XG52YXIgQ2hlY2tvdXRTZGtDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5DaGVja291dFNka0NvbnRleHQuZGlzcGxheU5hbWUgPSAnQ2hlY2tvdXRTZGtDb250ZXh0JztcbnZhciBwYXJzZUNoZWNrb3V0U2RrQ29udGV4dCA9IGZ1bmN0aW9uIHBhcnNlQ2hlY2tvdXRTZGtDb250ZXh0KGN0eCwgdXNlQ2FzZSkge1xuICBpZiAoIWN0eCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIENoZWNrb3V0UHJvdmlkZXIgY29udGV4dDsgWW91IG5lZWQgdG8gd3JhcCB0aGUgcGFydCBvZiB5b3VyIGFwcCB0aGF0IFwiLmNvbmNhdCh1c2VDYXNlLCBcIiBpbiBhbiA8Q2hlY2tvdXRQcm92aWRlcj4gcHJvdmlkZXIuXCIpKTtcbiAgfVxuXG4gIHJldHVybiBjdHg7XG59O1xudmFyIENoZWNrb3V0Q29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuQ2hlY2tvdXRDb250ZXh0LmRpc3BsYXlOYW1lID0gJ0NoZWNrb3V0Q29udGV4dCc7XG52YXIgZXh0cmFjdENoZWNrb3V0Q29udGV4dFZhbHVlID0gZnVuY3Rpb24gZXh0cmFjdENoZWNrb3V0Q29udGV4dFZhbHVlKGNoZWNrb3V0U2RrLCBzZXNzaW9uU3RhdGUpIHtcbiAgaWYgKCFjaGVja291dFNkaykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY2hlY2tvdXRTZGsub247XG4gICAgICBjaGVja291dFNkay5zZXNzaW9uO1xuICAgICAgdmFyIGFjdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoY2hlY2tvdXRTZGssIF9leGNsdWRlZCQxKTtcblxuICBpZiAoIXNlc3Npb25TdGF0ZSkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGNoZWNrb3V0U2RrLnNlc3Npb24oKSwgYWN0aW9ucyk7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmFzc2lnbihzZXNzaW9uU3RhdGUsIGFjdGlvbnMpO1xufTtcbnZhciBJTlZBTElEX1NUUklQRV9FUlJPUiQxID0gJ0ludmFsaWQgcHJvcCBgc3RyaXBlYCBzdXBwbGllZCB0byBgQ2hlY2tvdXRQcm92aWRlcmAuIFdlIHJlY29tbWVuZCB1c2luZyB0aGUgYGxvYWRTdHJpcGVgIHV0aWxpdHkgZnJvbSBgQHN0cmlwZS9zdHJpcGUtanNgLiBTZWUgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnRzLXByb3BzLXN0cmlwZSBmb3IgZGV0YWlscy4nO1xudmFyIENoZWNrb3V0UHJvdmlkZXIgPSBmdW5jdGlvbiBDaGVja291dFByb3ZpZGVyKF9yZWYpIHtcbiAgdmFyIHJhd1N0cmlwZVByb3AgPSBfcmVmLnN0cmlwZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW47XG4gIHZhciBwYXJzZWQgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcGFyc2VTdHJpcGVQcm9wKHJhd1N0cmlwZVByb3AsIElOVkFMSURfU1RSSVBFX0VSUk9SJDEpO1xuICB9LCBbcmF3U3RyaXBlUHJvcF0pOyAvLyBTdGF0ZSB1c2VkIHRvIHRyaWdnZXIgYSByZS1yZW5kZXIgd2hlbiBzZGsuc2Vzc2lvbiBpcyB1cGRhdGVkXG5cbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpLFxuICAgICAgX1JlYWN0JHVzZVN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF9SZWFjdCR1c2VTdGF0ZSwgMiksXG4gICAgICBzZXNzaW9uID0gX1JlYWN0JHVzZVN0YXRlMlswXSxcbiAgICAgIHNldFNlc3Npb24gPSBfUmVhY3QkdXNlU3RhdGUyWzFdO1xuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGUzID0gUmVhY3QudXNlU3RhdGUoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdHJpcGU6IHBhcnNlZC50YWcgPT09ICdzeW5jJyA/IHBhcnNlZC5zdHJpcGUgOiBudWxsLFxuICAgICAgY2hlY2tvdXRTZGs6IG51bGxcbiAgICB9O1xuICB9KSxcbiAgICAgIF9SZWFjdCR1c2VTdGF0ZTQgPSBfc2xpY2VkVG9BcnJheShfUmVhY3QkdXNlU3RhdGUzLCAyKSxcbiAgICAgIGN0eCA9IF9SZWFjdCR1c2VTdGF0ZTRbMF0sXG4gICAgICBzZXRDb250ZXh0ID0gX1JlYWN0JHVzZVN0YXRlNFsxXTtcblxuICB2YXIgc2FmZVNldENvbnRleHQgPSBmdW5jdGlvbiBzYWZlU2V0Q29udGV4dChzdHJpcGUsIGNoZWNrb3V0U2RrKSB7XG4gICAgc2V0Q29udGV4dChmdW5jdGlvbiAoY3R4KSB7XG4gICAgICBpZiAoY3R4LnN0cmlwZSAmJiBjdHguY2hlY2tvdXRTZGspIHtcbiAgICAgICAgcmV0dXJuIGN0eDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RyaXBlOiBzdHJpcGUsXG4gICAgICAgIGNoZWNrb3V0U2RrOiBjaGVja291dFNka1xuICAgICAgfTtcbiAgICB9KTtcbiAgfTsgLy8gUmVmIHVzZWQgdG8gYXZvaWQgY2FsbGluZyBpbml0Q2hlY2tvdXQgbXVsdGlwbGUgdGltZXMgd2hlbiBvcHRpb25zIGNoYW5nZXNcblxuXG4gIHZhciBpbml0Q2hlY2tvdXRDYWxsZWRSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciBpc01vdW50ZWQgPSB0cnVlO1xuXG4gICAgaWYgKHBhcnNlZC50YWcgPT09ICdhc3luYycgJiYgIWN0eC5zdHJpcGUpIHtcbiAgICAgIHBhcnNlZC5zdHJpcGVQcm9taXNlLnRoZW4oZnVuY3Rpb24gKHN0cmlwZSkge1xuICAgICAgICBpZiAoc3RyaXBlICYmIGlzTW91bnRlZCAmJiAhaW5pdENoZWNrb3V0Q2FsbGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAvLyBPbmx5IHVwZGF0ZSBjb250ZXh0IGlmIHRoZSBjb21wb25lbnQgaXMgc3RpbGwgbW91bnRlZFxuICAgICAgICAgIC8vIGFuZCBzdHJpcGUgaXMgbm90IG51bGwuIFdlIGFsbG93IHN0cmlwZSB0byBiZSBudWxsIHRvIG1ha2VcbiAgICAgICAgICAvLyBoYW5kbGluZyBTU1IgZWFzaWVyLlxuICAgICAgICAgIGluaXRDaGVja291dENhbGxlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICBzdHJpcGUuaW5pdENoZWNrb3V0KG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKGNoZWNrb3V0U2RrKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2tvdXRTZGspIHtcbiAgICAgICAgICAgICAgc2FmZVNldENvbnRleHQoc3RyaXBlLCBjaGVja291dFNkayk7XG4gICAgICAgICAgICAgIGNoZWNrb3V0U2RrLm9uKCdjaGFuZ2UnLCBzZXRTZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChwYXJzZWQudGFnID09PSAnc3luYycgJiYgcGFyc2VkLnN0cmlwZSAmJiAhaW5pdENoZWNrb3V0Q2FsbGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgIGluaXRDaGVja291dENhbGxlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIHBhcnNlZC5zdHJpcGUuaW5pdENoZWNrb3V0KG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKGNoZWNrb3V0U2RrKSB7XG4gICAgICAgIGlmIChjaGVja291dFNkaykge1xuICAgICAgICAgIHNhZmVTZXRDb250ZXh0KHBhcnNlZC5zdHJpcGUsIGNoZWNrb3V0U2RrKTtcbiAgICAgICAgICBjaGVja291dFNkay5vbignY2hhbmdlJywgc2V0U2Vzc2lvbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpc01vdW50ZWQgPSBmYWxzZTtcbiAgICB9O1xuICB9LCBbcGFyc2VkLCBjdHgsIG9wdGlvbnMsIHNldFNlc3Npb25dKTsgLy8gV2FybiBvbiBjaGFuZ2VzIHRvIHN0cmlwZSBwcm9wXG5cbiAgdmFyIHByZXZTdHJpcGUgPSB1c2VQcmV2aW91cyhyYXdTdHJpcGVQcm9wKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocHJldlN0cmlwZSAhPT0gbnVsbCAmJiBwcmV2U3RyaXBlICE9PSByYXdTdHJpcGVQcm9wKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1Vuc3VwcG9ydGVkIHByb3AgY2hhbmdlIG9uIENoZWNrb3V0UHJvdmlkZXI6IFlvdSBjYW5ub3QgY2hhbmdlIHRoZSBgc3RyaXBlYCBwcm9wIGFmdGVyIHNldHRpbmcgaXQuJyk7XG4gICAgfVxuICB9LCBbcHJldlN0cmlwZSwgcmF3U3RyaXBlUHJvcF0pOyAvLyBBcHBseSB1cGRhdGVzIHRvIGVsZW1lbnRzIHdoZW4gb3B0aW9ucyBwcm9wIGhhcyByZWxldmFudCBjaGFuZ2VzXG5cbiAgdmFyIHByZXZPcHRpb25zID0gdXNlUHJldmlvdXMob3B0aW9ucyk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9wcmV2T3B0aW9ucyRlbGVtZW50cywgX29wdGlvbnMkZWxlbWVudHNPcHRpO1xuXG4gICAgaWYgKCFjdHguY2hlY2tvdXRTZGspIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNBcHBlYXJhbmNlID0gcHJldk9wdGlvbnMgPT09IG51bGwgfHwgcHJldk9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfcHJldk9wdGlvbnMkZWxlbWVudHMgPSBwcmV2T3B0aW9ucy5lbGVtZW50c09wdGlvbnMpID09PSBudWxsIHx8IF9wcmV2T3B0aW9ucyRlbGVtZW50cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3ByZXZPcHRpb25zJGVsZW1lbnRzLmFwcGVhcmFuY2U7XG4gICAgdmFyIGN1cnJlbnRBcHBlYXJhbmNlID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX29wdGlvbnMkZWxlbWVudHNPcHRpID0gb3B0aW9ucy5lbGVtZW50c09wdGlvbnMpID09PSBudWxsIHx8IF9vcHRpb25zJGVsZW1lbnRzT3B0aSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX29wdGlvbnMkZWxlbWVudHNPcHRpLmFwcGVhcmFuY2U7XG5cbiAgICBpZiAoY3VycmVudEFwcGVhcmFuY2UgJiYgIWlzRXF1YWwoY3VycmVudEFwcGVhcmFuY2UsIHByZXZpb3VzQXBwZWFyYW5jZSkpIHtcbiAgICAgIGN0eC5jaGVja291dFNkay5jaGFuZ2VBcHBlYXJhbmNlKGN1cnJlbnRBcHBlYXJhbmNlKTtcbiAgICB9XG4gIH0sIFtvcHRpb25zLCBwcmV2T3B0aW9ucywgY3R4LmNoZWNrb3V0U2RrXSk7IC8vIEF0dGFjaCByZWFjdC1zdHJpcGUtanMgdmVyc2lvbiB0byBzdHJpcGUuanMgaW5zdGFuY2VcblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJlZ2lzdGVyV2l0aFN0cmlwZUpzKGN0eC5zdHJpcGUpO1xuICB9LCBbY3R4LnN0cmlwZV0pO1xuICB2YXIgY2hlY2tvdXRDb250ZXh0VmFsdWUgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZXh0cmFjdENoZWNrb3V0Q29udGV4dFZhbHVlKGN0eC5jaGVja291dFNkaywgc2Vzc2lvbik7XG4gIH0sIFtjdHguY2hlY2tvdXRTZGssIHNlc3Npb25dKTtcblxuICBpZiAoIWN0eC5jaGVja291dFNkaykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENoZWNrb3V0U2RrQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjdHhcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ2hlY2tvdXRDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGNoZWNrb3V0Q29udGV4dFZhbHVlXG4gIH0sIGNoaWxkcmVuKSk7XG59O1xuQ2hlY2tvdXRQcm92aWRlci5wcm9wVHlwZXMgPSB7XG4gIHN0cmlwZTogUHJvcFR5cGVzLmFueSxcbiAgb3B0aW9uczogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBmZXRjaENsaWVudFNlY3JldDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBlbGVtZW50c09wdGlvbnM6IFByb3BUeXBlcy5vYmplY3RcbiAgfSkuaXNSZXF1aXJlZFxufTtcbnZhciB1c2VDaGVja291dFNka0NvbnRleHRXaXRoVXNlQ2FzZSA9IGZ1bmN0aW9uIHVzZUNoZWNrb3V0U2RrQ29udGV4dFdpdGhVc2VDYXNlKHVzZUNhc2VTdHJpbmcpIHtcbiAgdmFyIGN0eCA9IFJlYWN0LnVzZUNvbnRleHQoQ2hlY2tvdXRTZGtDb250ZXh0KTtcbiAgcmV0dXJuIHBhcnNlQ2hlY2tvdXRTZGtDb250ZXh0KGN0eCwgdXNlQ2FzZVN0cmluZyk7XG59O1xudmFyIHVzZUVsZW1lbnRzT3JDaGVja291dFNka0NvbnRleHRXaXRoVXNlQ2FzZSA9IGZ1bmN0aW9uIHVzZUVsZW1lbnRzT3JDaGVja291dFNka0NvbnRleHRXaXRoVXNlQ2FzZSh1c2VDYXNlU3RyaW5nKSB7XG4gIHZhciBjaGVja291dFNka0NvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KENoZWNrb3V0U2RrQ29udGV4dCk7XG4gIHZhciBlbGVtZW50c0NvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KEVsZW1lbnRzQ29udGV4dCk7XG5cbiAgaWYgKGNoZWNrb3V0U2RrQ29udGV4dCAmJiBlbGVtZW50c0NvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgY2Fubm90IHdyYXAgdGhlIHBhcnQgb2YgeW91ciBhcHAgdGhhdCBcIi5jb25jYXQodXNlQ2FzZVN0cmluZywgXCIgaW4gYm90aCA8Q2hlY2tvdXRQcm92aWRlcj4gYW5kIDxFbGVtZW50cz4gcHJvdmlkZXJzLlwiKSk7XG4gIH1cblxuICBpZiAoY2hlY2tvdXRTZGtDb250ZXh0KSB7XG4gICAgcmV0dXJuIHBhcnNlQ2hlY2tvdXRTZGtDb250ZXh0KGNoZWNrb3V0U2RrQ29udGV4dCwgdXNlQ2FzZVN0cmluZyk7XG4gIH1cblxuICByZXR1cm4gcGFyc2VFbGVtZW50c0NvbnRleHQoZWxlbWVudHNDb250ZXh0LCB1c2VDYXNlU3RyaW5nKTtcbn07XG52YXIgdXNlQ2hlY2tvdXQgPSBmdW5jdGlvbiB1c2VDaGVja291dCgpIHtcbiAgLy8gZW5zdXJlIGl0J3MgaW4gQ2hlY2tvdXRQcm92aWRlclxuICB1c2VDaGVja291dFNka0NvbnRleHRXaXRoVXNlQ2FzZSgnY2FsbHMgdXNlQ2hlY2tvdXQoKScpO1xuICB2YXIgY3R4ID0gUmVhY3QudXNlQ29udGV4dChDaGVja291dENvbnRleHQpO1xuXG4gIGlmICghY3R4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCBDaGVja291dCBDb250ZXh0OyBZb3UgbmVlZCB0byB3cmFwIHRoZSBwYXJ0IG9mIHlvdXIgYXBwIHRoYXQgY2FsbHMgdXNlQ2hlY2tvdXQoKSBpbiBhbiA8Q2hlY2tvdXRQcm92aWRlcj4gcHJvdmlkZXIuJyk7XG4gIH1cblxuICByZXR1cm4gY3R4O1xufTtcblxudmFyIF9leGNsdWRlZCA9IFtcIm1vZGVcIl07XG5cbnZhciBjYXBpdGFsaXplZCA9IGZ1bmN0aW9uIGNhcGl0YWxpemVkKHN0cikge1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xufTtcblxudmFyIGNyZWF0ZUVsZW1lbnRDb21wb25lbnQgPSBmdW5jdGlvbiBjcmVhdGVFbGVtZW50Q29tcG9uZW50KHR5cGUsIGlzU2VydmVyKSB7XG4gIHZhciBkaXNwbGF5TmFtZSA9IFwiXCIuY29uY2F0KGNhcGl0YWxpemVkKHR5cGUpLCBcIkVsZW1lbnRcIik7XG5cbiAgdmFyIENsaWVudEVsZW1lbnQgPSBmdW5jdGlvbiBDbGllbnRFbGVtZW50KF9yZWYpIHtcbiAgICB2YXIgaWQgPSBfcmVmLmlkLFxuICAgICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgICAgX3JlZiRvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgICBvcHRpb25zID0gX3JlZiRvcHRpb25zID09PSB2b2lkIDAgPyB7fSA6IF9yZWYkb3B0aW9ucyxcbiAgICAgICAgb25CbHVyID0gX3JlZi5vbkJsdXIsXG4gICAgICAgIG9uRm9jdXMgPSBfcmVmLm9uRm9jdXMsXG4gICAgICAgIG9uUmVhZHkgPSBfcmVmLm9uUmVhZHksXG4gICAgICAgIG9uQ2hhbmdlID0gX3JlZi5vbkNoYW5nZSxcbiAgICAgICAgb25Fc2NhcGUgPSBfcmVmLm9uRXNjYXBlLFxuICAgICAgICBvbkNsaWNrID0gX3JlZi5vbkNsaWNrLFxuICAgICAgICBvbkxvYWRFcnJvciA9IF9yZWYub25Mb2FkRXJyb3IsXG4gICAgICAgIG9uTG9hZGVyU3RhcnQgPSBfcmVmLm9uTG9hZGVyU3RhcnQsXG4gICAgICAgIG9uTmV0d29ya3NDaGFuZ2UgPSBfcmVmLm9uTmV0d29ya3NDaGFuZ2UsXG4gICAgICAgIG9uQ29uZmlybSA9IF9yZWYub25Db25maXJtLFxuICAgICAgICBvbkNhbmNlbCA9IF9yZWYub25DYW5jZWwsXG4gICAgICAgIG9uU2hpcHBpbmdBZGRyZXNzQ2hhbmdlID0gX3JlZi5vblNoaXBwaW5nQWRkcmVzc0NoYW5nZSxcbiAgICAgICAgb25TaGlwcGluZ1JhdGVDaGFuZ2UgPSBfcmVmLm9uU2hpcHBpbmdSYXRlQ2hhbmdlO1xuICAgIHZhciBjdHggPSB1c2VFbGVtZW50c09yQ2hlY2tvdXRTZGtDb250ZXh0V2l0aFVzZUNhc2UoXCJtb3VudHMgPFwiLmNvbmNhdChkaXNwbGF5TmFtZSwgXCI+XCIpKTtcbiAgICB2YXIgZWxlbWVudHMgPSAnZWxlbWVudHMnIGluIGN0eCA/IGN0eC5lbGVtZW50cyA6IG51bGw7XG4gICAgdmFyIGNoZWNrb3V0U2RrID0gJ2NoZWNrb3V0U2RrJyBpbiBjdHggPyBjdHguY2hlY2tvdXRTZGsgOiBudWxsO1xuXG4gICAgdmFyIF9SZWFjdCR1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpLFxuICAgICAgICBfUmVhY3QkdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX1JlYWN0JHVzZVN0YXRlLCAyKSxcbiAgICAgICAgZWxlbWVudCA9IF9SZWFjdCR1c2VTdGF0ZTJbMF0sXG4gICAgICAgIHNldEVsZW1lbnQgPSBfUmVhY3QkdXNlU3RhdGUyWzFdO1xuXG4gICAgdmFyIGVsZW1lbnRSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gICAgdmFyIGRvbU5vZGUgPSBSZWFjdC51c2VSZWYobnVsbCk7IC8vIEZvciBldmVyeSBldmVudCB3aGVyZSB0aGUgbWVyY2hhbnQgcHJvdmlkZXMgYSBjYWxsYmFjaywgY2FsbCBlbGVtZW50Lm9uXG4gICAgLy8gd2l0aCB0aGF0IGNhbGxiYWNrLiBJZiB0aGUgbWVyY2hhbnQgZXZlciBjaGFuZ2VzIHRoZSBjYWxsYmFjaywgcmVtb3Zlc1xuICAgIC8vIHRoZSBvbGQgY2FsbGJhY2sgd2l0aCBlbGVtZW50Lm9mZiBhbmQgdGhlbiBjYWxsIGVsZW1lbnQub24gd2l0aCB0aGUgbmV3IG9uZS5cblxuICAgIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsICdibHVyJywgb25CbHVyKTtcbiAgICB1c2VBdHRhY2hFdmVudChlbGVtZW50LCAnZm9jdXMnLCBvbkZvY3VzKTtcbiAgICB1c2VBdHRhY2hFdmVudChlbGVtZW50LCAnZXNjYXBlJywgb25Fc2NhcGUpO1xuICAgIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsICdjbGljaycsIG9uQ2xpY2spO1xuICAgIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsICdsb2FkZXJyb3InLCBvbkxvYWRFcnJvcik7XG4gICAgdXNlQXR0YWNoRXZlbnQoZWxlbWVudCwgJ2xvYWRlcnN0YXJ0Jywgb25Mb2FkZXJTdGFydCk7XG4gICAgdXNlQXR0YWNoRXZlbnQoZWxlbWVudCwgJ25ldHdvcmtzY2hhbmdlJywgb25OZXR3b3Jrc0NoYW5nZSk7XG4gICAgdXNlQXR0YWNoRXZlbnQoZWxlbWVudCwgJ2NvbmZpcm0nLCBvbkNvbmZpcm0pO1xuICAgIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsICdjYW5jZWwnLCBvbkNhbmNlbCk7XG4gICAgdXNlQXR0YWNoRXZlbnQoZWxlbWVudCwgJ3NoaXBwaW5nYWRkcmVzc2NoYW5nZScsIG9uU2hpcHBpbmdBZGRyZXNzQ2hhbmdlKTtcbiAgICB1c2VBdHRhY2hFdmVudChlbGVtZW50LCAnc2hpcHBpbmdyYXRlY2hhbmdlJywgb25TaGlwcGluZ1JhdGVDaGFuZ2UpO1xuICAgIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsICdjaGFuZ2UnLCBvbkNoYW5nZSk7XG4gICAgdmFyIHJlYWR5Q2FsbGJhY2s7XG5cbiAgICBpZiAob25SZWFkeSkge1xuICAgICAgaWYgKHR5cGUgPT09ICdleHByZXNzQ2hlY2tvdXQnKSB7XG4gICAgICAgIC8vIFBhc3NlcyB0aHJvdWdoIHRoZSBldmVudCwgd2hpY2ggaW5jbHVkZXMgdmlzaWJsZSBQTSB0eXBlc1xuICAgICAgICByZWFkeUNhbGxiYWNrID0gb25SZWFkeTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvdGhlciBFbGVtZW50cywgcGFzcyB0aHJvdWdoIHRoZSBFbGVtZW50IGl0c2VsZi5cbiAgICAgICAgcmVhZHlDYWxsYmFjayA9IGZ1bmN0aW9uIHJlYWR5Q2FsbGJhY2soKSB7XG4gICAgICAgICAgb25SZWFkeShlbGVtZW50KTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB1c2VBdHRhY2hFdmVudChlbGVtZW50LCAncmVhZHknLCByZWFkeUNhbGxiYWNrKTtcbiAgICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGVsZW1lbnRSZWYuY3VycmVudCA9PT0gbnVsbCAmJiBkb21Ob2RlLmN1cnJlbnQgIT09IG51bGwgJiYgKGVsZW1lbnRzIHx8IGNoZWNrb3V0U2RrKSkge1xuICAgICAgICB2YXIgbmV3RWxlbWVudCA9IG51bGw7XG5cbiAgICAgICAgaWYgKGNoZWNrb3V0U2RrKSB7XG4gICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdwYXltZW50JzpcbiAgICAgICAgICAgICAgbmV3RWxlbWVudCA9IGNoZWNrb3V0U2RrLmNyZWF0ZVBheW1lbnRFbGVtZW50KG9wdGlvbnMpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnYWRkcmVzcyc6XG4gICAgICAgICAgICAgIGlmICgnbW9kZScgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHZhciBtb2RlID0gb3B0aW9ucy5tb2RlLFxuICAgICAgICAgICAgICAgICAgICByZXN0T3B0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvcHRpb25zLCBfZXhjbHVkZWQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1vZGUgPT09ICdzaGlwcGluZycpIHtcbiAgICAgICAgICAgICAgICAgIG5ld0VsZW1lbnQgPSBjaGVja291dFNkay5jcmVhdGVTaGlwcGluZ0FkZHJlc3NFbGVtZW50KHJlc3RPcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdiaWxsaW5nJykge1xuICAgICAgICAgICAgICAgICAgbmV3RWxlbWVudCA9IGNoZWNrb3V0U2RrLmNyZWF0ZUJpbGxpbmdBZGRyZXNzRWxlbWVudChyZXN0T3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgb3B0aW9ucy5tb2RlLiBtb2RlIG11c3QgYmUgJ2JpbGxpbmcnIG9yICdzaGlwcGluZycuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbXVzdCBzdXBwbHkgb3B0aW9ucy5tb2RlLiBtb2RlIG11c3QgYmUgJ2JpbGxpbmcnIG9yICdzaGlwcGluZycuXCIpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2V4cHJlc3NDaGVja291dCc6XG4gICAgICAgICAgICAgIG5ld0VsZW1lbnQgPSBjaGVja291dFNkay5jcmVhdGVFeHByZXNzQ2hlY2tvdXRFbGVtZW50KG9wdGlvbnMpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnY3VycmVuY3lTZWxlY3Rvcic6XG4gICAgICAgICAgICAgIG5ld0VsZW1lbnQgPSBjaGVja291dFNkay5jcmVhdGVDdXJyZW5jeVNlbGVjdG9yRWxlbWVudCgpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBFbGVtZW50IHR5cGUgXCIuY29uY2F0KGRpc3BsYXlOYW1lLCBcIi4gWW91IG11c3QgdXNlIGVpdGhlciB0aGUgPFBheW1lbnRFbGVtZW50IC8+LCA8QWRkcmVzc0VsZW1lbnQgb3B0aW9ucz17e21vZGU6ICdzaGlwcGluZyd9fSAvPiwgPEFkZHJlc3NFbGVtZW50IG9wdGlvbnM9e3ttb2RlOiAnYmlsbGluZyd9fSAvPiwgb3IgPEV4cHJlc3NDaGVja291dEVsZW1lbnQgLz4uXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudHMpIHtcbiAgICAgICAgICBuZXdFbGVtZW50ID0gZWxlbWVudHMuY3JlYXRlKHR5cGUsIG9wdGlvbnMpO1xuICAgICAgICB9IC8vIFN0b3JlIGVsZW1lbnQgaW4gYSByZWYgdG8gZW5zdXJlIGl0J3MgX2ltbWVkaWF0ZWx5XyBhdmFpbGFibGUgaW4gY2xlYW51cCBob29rcyBpbiBTdHJpY3RNb2RlXG5cblxuICAgICAgICBlbGVtZW50UmVmLmN1cnJlbnQgPSBuZXdFbGVtZW50OyAvLyBTdG9yZSBlbGVtZW50IGluIHN0YXRlIHRvIGZhY2lsaXRhdGUgZXZlbnQgbGlzdGVuZXIgYXR0YWNobWVudFxuXG4gICAgICAgIHNldEVsZW1lbnQobmV3RWxlbWVudCk7XG5cbiAgICAgICAgaWYgKG5ld0VsZW1lbnQpIHtcbiAgICAgICAgICBuZXdFbGVtZW50Lm1vdW50KGRvbU5vZGUuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBbZWxlbWVudHMsIGNoZWNrb3V0U2RrLCBvcHRpb25zXSk7XG4gICAgdmFyIHByZXZPcHRpb25zID0gdXNlUHJldmlvdXMob3B0aW9ucyk7XG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghZWxlbWVudFJlZi5jdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHVwZGF0ZXMgPSBleHRyYWN0QWxsb3dlZE9wdGlvbnNVcGRhdGVzKG9wdGlvbnMsIHByZXZPcHRpb25zLCBbJ3BheW1lbnRSZXF1ZXN0J10pO1xuXG4gICAgICBpZiAodXBkYXRlcyAmJiAndXBkYXRlJyBpbiBlbGVtZW50UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgZWxlbWVudFJlZi5jdXJyZW50LnVwZGF0ZSh1cGRhdGVzKTtcbiAgICAgIH1cbiAgICB9LCBbb3B0aW9ucywgcHJldk9wdGlvbnNdKTtcbiAgICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGVsZW1lbnRSZWYuY3VycmVudCAmJiB0eXBlb2YgZWxlbWVudFJlZi5jdXJyZW50LmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZWxlbWVudFJlZi5jdXJyZW50LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIGVsZW1lbnRSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHsvLyBEbyBub3RoaW5nXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgaWQ6IGlkLFxuICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICByZWY6IGRvbU5vZGVcbiAgICB9KTtcbiAgfTsgLy8gT25seSByZW5kZXIgdGhlIEVsZW1lbnQgd3JhcHBlciBpbiBhIHNlcnZlciBlbnZpcm9ubWVudC5cblxuXG4gIHZhciBTZXJ2ZXJFbGVtZW50ID0gZnVuY3Rpb24gU2VydmVyRWxlbWVudChwcm9wcykge1xuICAgIHVzZUVsZW1lbnRzT3JDaGVja291dFNka0NvbnRleHRXaXRoVXNlQ2FzZShcIm1vdW50cyA8XCIuY29uY2F0KGRpc3BsYXlOYW1lLCBcIj5cIikpO1xuICAgIHZhciBpZCA9IHByb3BzLmlkLFxuICAgICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWU7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lXG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIEVsZW1lbnQgPSBpc1NlcnZlciA/IFNlcnZlckVsZW1lbnQgOiBDbGllbnRFbGVtZW50O1xuICBFbGVtZW50LnByb3BUeXBlcyA9IHtcbiAgICBpZDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uQmx1cjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25Gb2N1czogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25SZWFkeTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25Fc2NhcGU6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uTG9hZEVycm9yOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkxvYWRlclN0YXJ0OiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbk5ldHdvcmtzQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkNvbmZpcm06IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uQ2FuY2VsOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvblNoaXBwaW5nQWRkcmVzc0NoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25TaGlwcGluZ1JhdGVDaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9wdGlvbnM6IFByb3BUeXBlcy5vYmplY3RcbiAgfTtcbiAgRWxlbWVudC5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuICBFbGVtZW50Ll9fZWxlbWVudFR5cGUgPSB0eXBlO1xuICByZXR1cm4gRWxlbWVudDtcbn07XG5cbnZhciBpc1NlcnZlciA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnO1xuXG52YXIgRW1iZWRkZWRDaGVja291dENvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbkVtYmVkZGVkQ2hlY2tvdXRDb250ZXh0LmRpc3BsYXlOYW1lID0gJ0VtYmVkZGVkQ2hlY2tvdXRQcm92aWRlckNvbnRleHQnO1xudmFyIHVzZUVtYmVkZGVkQ2hlY2tvdXRDb250ZXh0ID0gZnVuY3Rpb24gdXNlRW1iZWRkZWRDaGVja291dENvbnRleHQoKSB7XG4gIHZhciBjdHggPSBSZWFjdC51c2VDb250ZXh0KEVtYmVkZGVkQ2hlY2tvdXRDb250ZXh0KTtcblxuICBpZiAoIWN0eCkge1xuICAgIHRocm93IG5ldyBFcnJvcignPEVtYmVkZGVkQ2hlY2tvdXQ+IG11c3QgYmUgdXNlZCB3aXRoaW4gPEVtYmVkZGVkQ2hlY2tvdXRQcm92aWRlcj4nKTtcbiAgfVxuXG4gIHJldHVybiBjdHg7XG59O1xudmFyIElOVkFMSURfU1RSSVBFX0VSUk9SID0gJ0ludmFsaWQgcHJvcCBgc3RyaXBlYCBzdXBwbGllZCB0byBgRW1iZWRkZWRDaGVja291dFByb3ZpZGVyYC4gV2UgcmVjb21tZW5kIHVzaW5nIHRoZSBgbG9hZFN0cmlwZWAgdXRpbGl0eSBmcm9tIGBAc3RyaXBlL3N0cmlwZS1qc2AuIFNlZSBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudHMtcHJvcHMtc3RyaXBlIGZvciBkZXRhaWxzLic7XG52YXIgRW1iZWRkZWRDaGVja291dFByb3ZpZGVyID0gZnVuY3Rpb24gRW1iZWRkZWRDaGVja291dFByb3ZpZGVyKF9yZWYpIHtcbiAgdmFyIHJhd1N0cmlwZVByb3AgPSBfcmVmLnN0cmlwZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW47XG4gIHZhciBwYXJzZWQgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcGFyc2VTdHJpcGVQcm9wKHJhd1N0cmlwZVByb3AsIElOVkFMSURfU1RSSVBFX0VSUk9SKTtcbiAgfSwgW3Jhd1N0cmlwZVByb3BdKTtcbiAgdmFyIGVtYmVkZGVkQ2hlY2tvdXRQcm9taXNlID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICB2YXIgbG9hZGVkU3RyaXBlID0gUmVhY3QudXNlUmVmKG51bGwpO1xuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGUgPSBSZWFjdC51c2VTdGF0ZSh7XG4gICAgZW1iZWRkZWRDaGVja291dDogbnVsbFxuICB9KSxcbiAgICAgIF9SZWFjdCR1c2VTdGF0ZTIgPSBfc2xpY2VkVG9BcnJheShfUmVhY3QkdXNlU3RhdGUsIDIpLFxuICAgICAgY3R4ID0gX1JlYWN0JHVzZVN0YXRlMlswXSxcbiAgICAgIHNldENvbnRleHQgPSBfUmVhY3QkdXNlU3RhdGUyWzFdO1xuXG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgLy8gRG9uJ3Qgc3VwcG9ydCBhbnkgY3R4IHVwZGF0ZXMgb25jZSBlbWJlZGRlZENoZWNrb3V0IG9yIHN0cmlwZSBpcyBzZXQuXG4gICAgaWYgKGxvYWRlZFN0cmlwZS5jdXJyZW50IHx8IGVtYmVkZGVkQ2hlY2tvdXRQcm9taXNlLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc2V0U3RyaXBlQW5kSW5pdEVtYmVkZGVkQ2hlY2tvdXQgPSBmdW5jdGlvbiBzZXRTdHJpcGVBbmRJbml0RW1iZWRkZWRDaGVja291dChzdHJpcGUpIHtcbiAgICAgIGlmIChsb2FkZWRTdHJpcGUuY3VycmVudCB8fCBlbWJlZGRlZENoZWNrb3V0UHJvbWlzZS5jdXJyZW50KSByZXR1cm47XG4gICAgICBsb2FkZWRTdHJpcGUuY3VycmVudCA9IHN0cmlwZTtcbiAgICAgIGVtYmVkZGVkQ2hlY2tvdXRQcm9taXNlLmN1cnJlbnQgPSBsb2FkZWRTdHJpcGUuY3VycmVudC5pbml0RW1iZWRkZWRDaGVja291dChvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChlbWJlZGRlZENoZWNrb3V0KSB7XG4gICAgICAgIHNldENvbnRleHQoe1xuICAgICAgICAgIGVtYmVkZGVkQ2hlY2tvdXQ6IGVtYmVkZGVkQ2hlY2tvdXRcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9OyAvLyBGb3IgYW4gYXN5bmMgc3RyaXBlUHJvbWlzZSwgc3RvcmUgaXQgb25jZSByZXNvbHZlZFxuXG5cbiAgICBpZiAocGFyc2VkLnRhZyA9PT0gJ2FzeW5jJyAmJiAhbG9hZGVkU3RyaXBlLmN1cnJlbnQgJiYgKG9wdGlvbnMuY2xpZW50U2VjcmV0IHx8IG9wdGlvbnMuZmV0Y2hDbGllbnRTZWNyZXQpKSB7XG4gICAgICBwYXJzZWQuc3RyaXBlUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChzdHJpcGUpIHtcbiAgICAgICAgaWYgKHN0cmlwZSkge1xuICAgICAgICAgIHNldFN0cmlwZUFuZEluaXRFbWJlZGRlZENoZWNrb3V0KHN0cmlwZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAocGFyc2VkLnRhZyA9PT0gJ3N5bmMnICYmICFsb2FkZWRTdHJpcGUuY3VycmVudCAmJiAob3B0aW9ucy5jbGllbnRTZWNyZXQgfHwgb3B0aW9ucy5mZXRjaENsaWVudFNlY3JldCkpIHtcbiAgICAgIC8vIE9yLCBoYW5kbGUgYSBzeW5jIHN0cmlwZSBpbnN0YW5jZSBnb2luZyBmcm9tIG51bGwgLT4gcG9wdWxhdGVkXG4gICAgICBzZXRTdHJpcGVBbmRJbml0RW1iZWRkZWRDaGVja291dChwYXJzZWQuc3RyaXBlKTtcbiAgICB9XG4gIH0sIFtwYXJzZWQsIG9wdGlvbnMsIGN0eCwgbG9hZGVkU3RyaXBlXSk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgLy8gY2xlYW51cCBvbiB1bm1vdW50XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIElmIGVtYmVkZGVkIGNoZWNrb3V0IGlzIGZ1bGx5IGluaXRpYWxpemVkLCBkZXN0cm95IGl0LlxuICAgICAgaWYgKGN0eC5lbWJlZGRlZENoZWNrb3V0KSB7XG4gICAgICAgIGVtYmVkZGVkQ2hlY2tvdXRQcm9taXNlLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICBjdHguZW1iZWRkZWRDaGVja291dC5kZXN0cm95KCk7XG4gICAgICB9IGVsc2UgaWYgKGVtYmVkZGVkQ2hlY2tvdXRQcm9taXNlLmN1cnJlbnQpIHtcbiAgICAgICAgLy8gSWYgZW1iZWRkZWQgY2hlY2tvdXQgaXMgc3RpbGwgaW5pdGlhbGl6aW5nLCBkZXN0cm95IGl0IG9uY2VcbiAgICAgICAgLy8gaXQncyBkb25lLiBUaGlzIGNvdWxkIGJlIGNhdXNlZCBieSB1bm1vdW50aW5nIHZlcnkgcXVpY2tseVxuICAgICAgICAvLyBhZnRlciBtb3VudGluZy5cbiAgICAgICAgZW1iZWRkZWRDaGVja291dFByb21pc2UuY3VycmVudC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbWJlZGRlZENoZWNrb3V0UHJvbWlzZS5jdXJyZW50ID0gbnVsbDtcblxuICAgICAgICAgIGlmIChjdHguZW1iZWRkZWRDaGVja291dCkge1xuICAgICAgICAgICAgY3R4LmVtYmVkZGVkQ2hlY2tvdXQuZGVzdHJveSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2N0eC5lbWJlZGRlZENoZWNrb3V0XSk7IC8vIEF0dGFjaCByZWFjdC1zdHJpcGUtanMgdmVyc2lvbiB0byBzdHJpcGUuanMgaW5zdGFuY2VcblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJlZ2lzdGVyV2l0aFN0cmlwZUpzKGxvYWRlZFN0cmlwZSk7XG4gIH0sIFtsb2FkZWRTdHJpcGVdKTsgLy8gV2FybiBvbiBjaGFuZ2VzIHRvIHN0cmlwZSBwcm9wLlxuICAvLyBUaGUgc3RyaXBlIHByb3AgdmFsdWUgY2FuIG9ubHkgZ28gZnJvbSBudWxsIHRvIG5vbi1udWxsIG9uY2UgYW5kXG4gIC8vIGNhbid0IGJlIGNoYW5nZWQgYWZ0ZXIgdGhhdC5cblxuICB2YXIgcHJldlN0cmlwZSA9IHVzZVByZXZpb3VzKHJhd1N0cmlwZVByb3ApO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChwcmV2U3RyaXBlICE9PSBudWxsICYmIHByZXZTdHJpcGUgIT09IHJhd1N0cmlwZVByb3ApIHtcbiAgICAgIGNvbnNvbGUud2FybignVW5zdXBwb3J0ZWQgcHJvcCBjaGFuZ2Ugb24gRW1iZWRkZWRDaGVja291dFByb3ZpZGVyOiBZb3UgY2Fubm90IGNoYW5nZSB0aGUgYHN0cmlwZWAgcHJvcCBhZnRlciBzZXR0aW5nIGl0LicpO1xuICAgIH1cbiAgfSwgW3ByZXZTdHJpcGUsIHJhd1N0cmlwZVByb3BdKTsgLy8gV2FybiBvbiBjaGFuZ2VzIHRvIG9wdGlvbnMuXG5cbiAgdmFyIHByZXZPcHRpb25zID0gdXNlUHJldmlvdXMob3B0aW9ucyk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHByZXZPcHRpb25zID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1Vuc3VwcG9ydGVkIHByb3AgY2hhbmdlIG9uIEVtYmVkZGVkQ2hlY2tvdXRQcm92aWRlcjogWW91IGNhbm5vdCB1bnNldCBvcHRpb25zIGFmdGVyIHNldHRpbmcgdGhlbS4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5jbGllbnRTZWNyZXQgPT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLmZldGNoQ2xpZW50U2VjcmV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnNvbGUud2FybignSW52YWxpZCBwcm9wcyBwYXNzZWQgdG8gRW1iZWRkZWRDaGVja291dFByb3ZpZGVyOiBZb3UgbXVzdCBwcm92aWRlIG9uZSBvZiBlaXRoZXIgYG9wdGlvbnMuZmV0Y2hDbGllbnRTZWNyZXRgIG9yIGBvcHRpb25zLmNsaWVudFNlY3JldGAuJyk7XG4gICAgfVxuXG4gICAgaWYgKHByZXZPcHRpb25zLmNsaWVudFNlY3JldCAhPSBudWxsICYmIG9wdGlvbnMuY2xpZW50U2VjcmV0ICE9PSBwcmV2T3B0aW9ucy5jbGllbnRTZWNyZXQpIHtcbiAgICAgIGNvbnNvbGUud2FybignVW5zdXBwb3J0ZWQgcHJvcCBjaGFuZ2Ugb24gRW1iZWRkZWRDaGVja291dFByb3ZpZGVyOiBZb3UgY2Fubm90IGNoYW5nZSB0aGUgY2xpZW50IHNlY3JldCBhZnRlciBzZXR0aW5nIGl0LiBVbm1vdW50IGFuZCBjcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgRW1iZWRkZWRDaGVja291dFByb3ZpZGVyIGluc3RlYWQuJyk7XG4gICAgfVxuXG4gICAgaWYgKHByZXZPcHRpb25zLmZldGNoQ2xpZW50U2VjcmV0ICE9IG51bGwgJiYgb3B0aW9ucy5mZXRjaENsaWVudFNlY3JldCAhPT0gcHJldk9wdGlvbnMuZmV0Y2hDbGllbnRTZWNyZXQpIHtcbiAgICAgIGNvbnNvbGUud2FybignVW5zdXBwb3J0ZWQgcHJvcCBjaGFuZ2Ugb24gRW1iZWRkZWRDaGVja291dFByb3ZpZGVyOiBZb3UgY2Fubm90IGNoYW5nZSBmZXRjaENsaWVudFNlY3JldCBhZnRlciBzZXR0aW5nIGl0LiBVbm1vdW50IGFuZCBjcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgRW1iZWRkZWRDaGVja291dFByb3ZpZGVyIGluc3RlYWQuJyk7XG4gICAgfVxuXG4gICAgaWYgKHByZXZPcHRpb25zLm9uQ29tcGxldGUgIT0gbnVsbCAmJiBvcHRpb25zLm9uQ29tcGxldGUgIT09IHByZXZPcHRpb25zLm9uQ29tcGxldGUpIHtcbiAgICAgIGNvbnNvbGUud2FybignVW5zdXBwb3J0ZWQgcHJvcCBjaGFuZ2Ugb24gRW1iZWRkZWRDaGVja291dFByb3ZpZGVyOiBZb3UgY2Fubm90IGNoYW5nZSB0aGUgb25Db21wbGV0ZSBvcHRpb24gYWZ0ZXIgc2V0dGluZyBpdC4nKTtcbiAgICB9XG5cbiAgICBpZiAocHJldk9wdGlvbnMub25TaGlwcGluZ0RldGFpbHNDaGFuZ2UgIT0gbnVsbCAmJiBvcHRpb25zLm9uU2hpcHBpbmdEZXRhaWxzQ2hhbmdlICE9PSBwcmV2T3B0aW9ucy5vblNoaXBwaW5nRGV0YWlsc0NoYW5nZSkge1xuICAgICAgY29uc29sZS53YXJuKCdVbnN1cHBvcnRlZCBwcm9wIGNoYW5nZSBvbiBFbWJlZGRlZENoZWNrb3V0UHJvdmlkZXI6IFlvdSBjYW5ub3QgY2hhbmdlIHRoZSBvblNoaXBwaW5nRGV0YWlsc0NoYW5nZSBvcHRpb24gYWZ0ZXIgc2V0dGluZyBpdC4nKTtcbiAgICB9XG5cbiAgICBpZiAocHJldk9wdGlvbnMub25MaW5lSXRlbXNDaGFuZ2UgIT0gbnVsbCAmJiBvcHRpb25zLm9uTGluZUl0ZW1zQ2hhbmdlICE9PSBwcmV2T3B0aW9ucy5vbkxpbmVJdGVtc0NoYW5nZSkge1xuICAgICAgY29uc29sZS53YXJuKCdVbnN1cHBvcnRlZCBwcm9wIGNoYW5nZSBvbiBFbWJlZGRlZENoZWNrb3V0UHJvdmlkZXI6IFlvdSBjYW5ub3QgY2hhbmdlIHRoZSBvbkxpbmVJdGVtc0NoYW5nZSBvcHRpb24gYWZ0ZXIgc2V0dGluZyBpdC4nKTtcbiAgICB9XG4gIH0sIFtwcmV2T3B0aW9ucywgb3B0aW9uc10pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRW1iZWRkZWRDaGVja291dENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY3R4XG4gIH0sIGNoaWxkcmVuKTtcbn07XG5cbnZhciBFbWJlZGRlZENoZWNrb3V0Q2xpZW50RWxlbWVudCA9IGZ1bmN0aW9uIEVtYmVkZGVkQ2hlY2tvdXRDbGllbnRFbGVtZW50KF9yZWYpIHtcbiAgdmFyIGlkID0gX3JlZi5pZCxcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lO1xuXG4gIHZhciBfdXNlRW1iZWRkZWRDaGVja291dEMgPSB1c2VFbWJlZGRlZENoZWNrb3V0Q29udGV4dCgpLFxuICAgICAgZW1iZWRkZWRDaGVja291dCA9IF91c2VFbWJlZGRlZENoZWNrb3V0Qy5lbWJlZGRlZENoZWNrb3V0O1xuXG4gIHZhciBpc01vdW50ZWQgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICB2YXIgZG9tTm9kZSA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWlzTW91bnRlZC5jdXJyZW50ICYmIGVtYmVkZGVkQ2hlY2tvdXQgJiYgZG9tTm9kZS5jdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICBlbWJlZGRlZENoZWNrb3V0Lm1vdW50KGRvbU5vZGUuY3VycmVudCk7XG4gICAgICBpc01vdW50ZWQuY3VycmVudCA9IHRydWU7XG4gICAgfSAvLyBDbGVhbiB1cCBvbiB1bm1vdW50XG5cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaXNNb3VudGVkLmN1cnJlbnQgJiYgZW1iZWRkZWRDaGVja291dCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGVtYmVkZGVkQ2hlY2tvdXQudW5tb3VudCgpO1xuICAgICAgICAgIGlzTW91bnRlZC5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsvLyBEbyBub3RoaW5nLlxuICAgICAgICAgIC8vIFBhcmVudCBlZmZlY3RzIGFyZSBkZXN0cm95ZWQgYmVmb3JlIGNoaWxkIGVmZmVjdHMsIHNvXG4gICAgICAgICAgLy8gaW4gY2FzZXMgd2hlcmUgYm90aCB0aGUgRW1iZWRkZWRDaGVja291dFByb3ZpZGVyIGFuZFxuICAgICAgICAgIC8vIHRoZSBFbWJlZGRlZENoZWNrb3V0IGNvbXBvbmVudCBhcmUgcmVtb3ZlZCBhdCB0aGUgc2FtZVxuICAgICAgICAgIC8vIHRpbWUsIHRoZSBlbWJlZGRlZENoZWNrb3V0IGluc3RhbmNlIHdpbGwgYmUgZGVzdHJveWVkLFxuICAgICAgICAgIC8vIHdoaWNoIGNhdXNlcyBhbiBlcnJvciB3aGVuIGNhbGxpbmcgdW5tb3VudC5cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0sIFtlbWJlZGRlZENoZWNrb3V0XSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgcmVmOiBkb21Ob2RlLFxuICAgIGlkOiBpZCxcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVxuICB9KTtcbn07IC8vIE9ubHkgcmVuZGVyIHRoZSB3cmFwcGVyIGluIGEgc2VydmVyIGVudmlyb25tZW50LlxuXG5cbnZhciBFbWJlZGRlZENoZWNrb3V0U2VydmVyRWxlbWVudCA9IGZ1bmN0aW9uIEVtYmVkZGVkQ2hlY2tvdXRTZXJ2ZXJFbGVtZW50KF9yZWYyKSB7XG4gIHZhciBpZCA9IF9yZWYyLmlkLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZjIuY2xhc3NOYW1lO1xuICAvLyBWYWxpZGF0ZSB0aGF0IHdlIGFyZSBpbiB0aGUgcmlnaHQgY29udGV4dCBieSBjYWxsaW5nIHVzZUVtYmVkZGVkQ2hlY2tvdXRDb250ZXh0LlxuICB1c2VFbWJlZGRlZENoZWNrb3V0Q29udGV4dCgpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGlkOiBpZCxcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVxuICB9KTtcbn07XG5cbnZhciBFbWJlZGRlZENoZWNrb3V0ID0gaXNTZXJ2ZXIgPyBFbWJlZGRlZENoZWNrb3V0U2VydmVyRWxlbWVudCA6IEVtYmVkZGVkQ2hlY2tvdXRDbGllbnRFbGVtZW50O1xuXG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCN1c2VzdHJpcGUtaG9va1xuICovXG5cbnZhciB1c2VTdHJpcGUgPSBmdW5jdGlvbiB1c2VTdHJpcGUoKSB7XG4gIHZhciBfdXNlRWxlbWVudHNPckNoZWNrb3UgPSB1c2VFbGVtZW50c09yQ2hlY2tvdXRTZGtDb250ZXh0V2l0aFVzZUNhc2UoJ2NhbGxzIHVzZVN0cmlwZSgpJyksXG4gICAgICBzdHJpcGUgPSBfdXNlRWxlbWVudHNPckNoZWNrb3Uuc3RyaXBlO1xuXG4gIHJldHVybiBzdHJpcGU7XG59O1xuXG4vKipcbiAqIFJlcXVpcmVzIGJldGEgYWNjZXNzOlxuICogQ29udGFjdCBbU3RyaXBlIHN1cHBvcnRdKGh0dHBzOi8vc3VwcG9ydC5zdHJpcGUuY29tLykgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBBdUJhbmtBY2NvdW50RWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2F1QmFua0FjY291bnQnLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgQ2FyZEVsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdjYXJkJywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzXG4gKi9cblxudmFyIENhcmROdW1iZXJFbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgnY2FyZE51bWJlcicsIGlzU2VydmVyKTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBDYXJkRXhwaXJ5RWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2NhcmRFeHBpcnknLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgQ2FyZEN2Y0VsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdjYXJkQ3ZjJywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzXG4gKi9cblxudmFyIEZweEJhbmtFbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgnZnB4QmFuaycsIGlzU2VydmVyKTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBJYmFuRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2liYW4nLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgSWRlYWxCYW5rRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2lkZWFsQmFuaycsIGlzU2VydmVyKTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBQMjRCYW5rRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ3AyNEJhbmsnLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgRXBzQmFua0VsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdlcHNCYW5rJywgaXNTZXJ2ZXIpO1xudmFyIFBheW1lbnRFbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgncGF5bWVudCcsIGlzU2VydmVyKTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBFeHByZXNzQ2hlY2tvdXRFbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgnZXhwcmVzc0NoZWNrb3V0JywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBSZXF1aXJlcyBiZXRhIGFjY2VzczpcbiAqIENvbnRhY3QgW1N0cmlwZSBzdXBwb3J0XShodHRwczovL3N1cHBvcnQuc3RyaXBlLmNvbS8pIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICovXG5cbnZhciBDdXJyZW5jeVNlbGVjdG9yRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2N1cnJlbmN5U2VsZWN0b3InLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgUGF5bWVudFJlcXVlc3RCdXR0b25FbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgncGF5bWVudFJlcXVlc3RCdXR0b24nLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgTGlua0F1dGhlbnRpY2F0aW9uRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2xpbmtBdXRoZW50aWNhdGlvbicsIGlzU2VydmVyKTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBBZGRyZXNzRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2FkZHJlc3MnLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKiBVc2UgYEFkZHJlc3NFbGVtZW50YCBpbnN0ZWFkLlxuICpcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgU2hpcHBpbmdBZGRyZXNzRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ3NoaXBwaW5nQWRkcmVzcycsIGlzU2VydmVyKTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBQYXltZW50TWV0aG9kTWVzc2FnaW5nRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ3BheW1lbnRNZXRob2RNZXNzYWdpbmcnLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgQWZmaXJtTWVzc2FnZUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdhZmZpcm1NZXNzYWdlJywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzXG4gKi9cblxudmFyIEFmdGVycGF5Q2xlYXJwYXlNZXNzYWdlRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2FmdGVycGF5Q2xlYXJwYXlNZXNzYWdlJywgaXNTZXJ2ZXIpO1xuXG5leHBvcnQgeyBBZGRyZXNzRWxlbWVudCwgQWZmaXJtTWVzc2FnZUVsZW1lbnQsIEFmdGVycGF5Q2xlYXJwYXlNZXNzYWdlRWxlbWVudCwgQXVCYW5rQWNjb3VudEVsZW1lbnQsIENhcmRDdmNFbGVtZW50LCBDYXJkRWxlbWVudCwgQ2FyZEV4cGlyeUVsZW1lbnQsIENhcmROdW1iZXJFbGVtZW50LCBDaGVja291dFByb3ZpZGVyLCBDdXJyZW5jeVNlbGVjdG9yRWxlbWVudCwgRWxlbWVudHMsIEVsZW1lbnRzQ29uc3VtZXIsIEVtYmVkZGVkQ2hlY2tvdXQsIEVtYmVkZGVkQ2hlY2tvdXRQcm92aWRlciwgRXBzQmFua0VsZW1lbnQsIEV4cHJlc3NDaGVja291dEVsZW1lbnQsIEZweEJhbmtFbGVtZW50LCBJYmFuRWxlbWVudCwgSWRlYWxCYW5rRWxlbWVudCwgTGlua0F1dGhlbnRpY2F0aW9uRWxlbWVudCwgUDI0QmFua0VsZW1lbnQsIFBheW1lbnRFbGVtZW50LCBQYXltZW50TWV0aG9kTWVzc2FnaW5nRWxlbWVudCwgUGF5bWVudFJlcXVlc3RCdXR0b25FbGVtZW50LCBTaGlwcGluZ0FkZHJlc3NFbGVtZW50LCB1c2VDaGVja291dCwgdXNlRWxlbWVudHMsIHVzZVN0cmlwZSB9O1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwiUHJvcFR5cGVzIiwib3duS2V5cyIsIm9iamVjdCIsImVudW1lcmFibGVPbmx5Iiwia2V5cyIsIk9iamVjdCIsImdldE93blByb3BlcnR5U3ltYm9scyIsInN5bWJvbHMiLCJmaWx0ZXIiLCJzeW0iLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwicHVzaCIsImFwcGx5IiwiX29iamVjdFNwcmVhZDIiLCJ0YXJnZXQiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwiZm9yRWFjaCIsImtleSIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZGVmaW5lUHJvcGVydHkiLCJfdHlwZW9mIiwib2JqIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsInZhbHVlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsImV4Y2x1ZGVkIiwic291cmNlS2V5cyIsImluZGV4T2YiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJzb3VyY2VTeW1ib2xLZXlzIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJjYWxsIiwiX3NsaWNlZFRvQXJyYXkiLCJhcnIiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVSZXN0IiwiQXJyYXkiLCJpc0FycmF5IiwiX2kiLCJfYXJyIiwiX24iLCJfZCIsIl9zIiwiX2UiLCJuZXh0IiwiZG9uZSIsImVyciIsIm8iLCJtaW5MZW4iLCJfYXJyYXlMaWtlVG9BcnJheSIsIm4iLCJ0b1N0cmluZyIsInNsaWNlIiwibmFtZSIsImZyb20iLCJ0ZXN0IiwibGVuIiwiYXJyMiIsIlR5cGVFcnJvciIsInVzZUF0dGFjaEV2ZW50IiwiZWxlbWVudCIsImV2ZW50IiwiY2IiLCJjYkRlZmluZWQiLCJjYlJlZiIsInVzZVJlZiIsInVzZUVmZmVjdCIsImN1cnJlbnQiLCJkZWNvcmF0ZWRDYiIsIm9uIiwib2ZmIiwidXNlUHJldmlvdXMiLCJyZWYiLCJpc1Vua25vd25PYmplY3QiLCJyYXciLCJpc1Byb21pc2UiLCJ0aGVuIiwiaXNTdHJpcGUiLCJlbGVtZW50cyIsImNyZWF0ZVRva2VuIiwiY3JlYXRlUGF5bWVudE1ldGhvZCIsImNvbmZpcm1DYXJkUGF5bWVudCIsIlBMQUlOX09CSkVDVF9TVFIiLCJpc0VxdWFsIiwibGVmdCIsInJpZ2h0IiwibGVmdEFycmF5IiwicmlnaHRBcnJheSIsImxlZnRQbGFpbk9iamVjdCIsInJpZ2h0UGxhaW5PYmplY3QiLCJsZWZ0S2V5cyIsInJpZ2h0S2V5cyIsImtleVNldCIsImFsbEtleXMiLCJsIiwiciIsInByZWQiLCJldmVyeSIsImV4dHJhY3RBbGxvd2VkT3B0aW9uc1VwZGF0ZXMiLCJvcHRpb25zIiwicHJldk9wdGlvbnMiLCJpbW11dGFibGVLZXlzIiwicmVkdWNlIiwibmV3T3B0aW9ucyIsImlzVXBkYXRlZCIsImluY2x1ZGVzIiwiY29uc29sZSIsIndhcm4iLCJjb25jYXQiLCJJTlZBTElEX1NUUklQRV9FUlJPUiQyIiwidmFsaWRhdGVTdHJpcGUiLCJtYXliZVN0cmlwZSIsImVycm9yTXNnIiwidW5kZWZpbmVkIiwiRXJyb3IiLCJwYXJzZVN0cmlwZVByb3AiLCJ0YWciLCJzdHJpcGVQcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZXN1bHQiLCJzdHJpcGUiLCJyZWdpc3RlcldpdGhTdHJpcGVKcyIsIl9yZWdpc3RlcldyYXBwZXIiLCJyZWdpc3RlckFwcEluZm8iLCJ2ZXJzaW9uIiwidXJsIiwiRWxlbWVudHNDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsImRpc3BsYXlOYW1lIiwicGFyc2VFbGVtZW50c0NvbnRleHQiLCJjdHgiLCJ1c2VDYXNlIiwiRWxlbWVudHMiLCJfcmVmIiwicmF3U3RyaXBlUHJvcCIsImNoaWxkcmVuIiwicGFyc2VkIiwidXNlTWVtbyIsIl9SZWFjdCR1c2VTdGF0ZSIsInVzZVN0YXRlIiwiX1JlYWN0JHVzZVN0YXRlMiIsInNldENvbnRleHQiLCJpc01vdW50ZWQiLCJzYWZlU2V0Q29udGV4dCIsInByZXZTdHJpcGUiLCJ1cGRhdGVzIiwidXBkYXRlIiwiY3JlYXRlRWxlbWVudCIsIlByb3ZpZGVyIiwicHJvcFR5cGVzIiwiYW55IiwidXNlRWxlbWVudHNDb250ZXh0V2l0aFVzZUNhc2UiLCJ1c2VDYXNlTWVzc2FnZSIsInVzZUNvbnRleHQiLCJ1c2VFbGVtZW50cyIsIl91c2VFbGVtZW50c0NvbnRleHRXaSIsIkVsZW1lbnRzQ29uc3VtZXIiLCJfcmVmMiIsImZ1bmMiLCJpc1JlcXVpcmVkIiwiX2V4Y2x1ZGVkJDEiLCJDaGVja291dFNka0NvbnRleHQiLCJwYXJzZUNoZWNrb3V0U2RrQ29udGV4dCIsIkNoZWNrb3V0Q29udGV4dCIsImV4dHJhY3RDaGVja291dENvbnRleHRWYWx1ZSIsImNoZWNrb3V0U2RrIiwic2Vzc2lvblN0YXRlIiwic2Vzc2lvbiIsImFjdGlvbnMiLCJhc3NpZ24iLCJJTlZBTElEX1NUUklQRV9FUlJPUiQxIiwiQ2hlY2tvdXRQcm92aWRlciIsInNldFNlc3Npb24iLCJfUmVhY3QkdXNlU3RhdGUzIiwiX1JlYWN0JHVzZVN0YXRlNCIsImluaXRDaGVja291dENhbGxlZFJlZiIsImluaXRDaGVja291dCIsIl9wcmV2T3B0aW9ucyRlbGVtZW50cyIsIl9vcHRpb25zJGVsZW1lbnRzT3B0aSIsInByZXZpb3VzQXBwZWFyYW5jZSIsImVsZW1lbnRzT3B0aW9ucyIsImFwcGVhcmFuY2UiLCJjdXJyZW50QXBwZWFyYW5jZSIsImNoYW5nZUFwcGVhcmFuY2UiLCJjaGVja291dENvbnRleHRWYWx1ZSIsInNoYXBlIiwiZmV0Y2hDbGllbnRTZWNyZXQiLCJ1c2VDaGVja291dFNka0NvbnRleHRXaXRoVXNlQ2FzZSIsInVzZUNhc2VTdHJpbmciLCJ1c2VFbGVtZW50c09yQ2hlY2tvdXRTZGtDb250ZXh0V2l0aFVzZUNhc2UiLCJjaGVja291dFNka0NvbnRleHQiLCJlbGVtZW50c0NvbnRleHQiLCJ1c2VDaGVja291dCIsIl9leGNsdWRlZCIsImNhcGl0YWxpemVkIiwic3RyIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJjcmVhdGVFbGVtZW50Q29tcG9uZW50IiwidHlwZSIsImlzU2VydmVyIiwiQ2xpZW50RWxlbWVudCIsImlkIiwiY2xhc3NOYW1lIiwiX3JlZiRvcHRpb25zIiwib25CbHVyIiwib25Gb2N1cyIsIm9uUmVhZHkiLCJvbkNoYW5nZSIsIm9uRXNjYXBlIiwib25DbGljayIsIm9uTG9hZEVycm9yIiwib25Mb2FkZXJTdGFydCIsIm9uTmV0d29ya3NDaGFuZ2UiLCJvbkNvbmZpcm0iLCJvbkNhbmNlbCIsIm9uU2hpcHBpbmdBZGRyZXNzQ2hhbmdlIiwib25TaGlwcGluZ1JhdGVDaGFuZ2UiLCJzZXRFbGVtZW50IiwiZWxlbWVudFJlZiIsImRvbU5vZGUiLCJyZWFkeUNhbGxiYWNrIiwidXNlTGF5b3V0RWZmZWN0IiwibmV3RWxlbWVudCIsImNyZWF0ZVBheW1lbnRFbGVtZW50IiwibW9kZSIsInJlc3RPcHRpb25zIiwiY3JlYXRlU2hpcHBpbmdBZGRyZXNzRWxlbWVudCIsImNyZWF0ZUJpbGxpbmdBZGRyZXNzRWxlbWVudCIsImNyZWF0ZUV4cHJlc3NDaGVja291dEVsZW1lbnQiLCJjcmVhdGVDdXJyZW5jeVNlbGVjdG9yRWxlbWVudCIsImNyZWF0ZSIsIm1vdW50IiwiZGVzdHJveSIsImVycm9yIiwiU2VydmVyRWxlbWVudCIsInByb3BzIiwiRWxlbWVudCIsInN0cmluZyIsIl9fZWxlbWVudFR5cGUiLCJFbWJlZGRlZENoZWNrb3V0Q29udGV4dCIsInVzZUVtYmVkZGVkQ2hlY2tvdXRDb250ZXh0IiwiSU5WQUxJRF9TVFJJUEVfRVJST1IiLCJFbWJlZGRlZENoZWNrb3V0UHJvdmlkZXIiLCJlbWJlZGRlZENoZWNrb3V0UHJvbWlzZSIsImxvYWRlZFN0cmlwZSIsImVtYmVkZGVkQ2hlY2tvdXQiLCJzZXRTdHJpcGVBbmRJbml0RW1iZWRkZWRDaGVja291dCIsImluaXRFbWJlZGRlZENoZWNrb3V0IiwiY2xpZW50U2VjcmV0Iiwib25Db21wbGV0ZSIsIm9uU2hpcHBpbmdEZXRhaWxzQ2hhbmdlIiwib25MaW5lSXRlbXNDaGFuZ2UiLCJFbWJlZGRlZENoZWNrb3V0Q2xpZW50RWxlbWVudCIsIl91c2VFbWJlZGRlZENoZWNrb3V0QyIsInVubW91bnQiLCJlIiwiRW1iZWRkZWRDaGVja291dFNlcnZlckVsZW1lbnQiLCJFbWJlZGRlZENoZWNrb3V0IiwidXNlU3RyaXBlIiwiX3VzZUVsZW1lbnRzT3JDaGVja291IiwiQXVCYW5rQWNjb3VudEVsZW1lbnQiLCJDYXJkRWxlbWVudCIsIkNhcmROdW1iZXJFbGVtZW50IiwiQ2FyZEV4cGlyeUVsZW1lbnQiLCJDYXJkQ3ZjRWxlbWVudCIsIkZweEJhbmtFbGVtZW50IiwiSWJhbkVsZW1lbnQiLCJJZGVhbEJhbmtFbGVtZW50IiwiUDI0QmFua0VsZW1lbnQiLCJFcHNCYW5rRWxlbWVudCIsIlBheW1lbnRFbGVtZW50IiwiRXhwcmVzc0NoZWNrb3V0RWxlbWVudCIsIkN1cnJlbmN5U2VsZWN0b3JFbGVtZW50IiwiUGF5bWVudFJlcXVlc3RCdXR0b25FbGVtZW50IiwiTGlua0F1dGhlbnRpY2F0aW9uRWxlbWVudCIsIkFkZHJlc3NFbGVtZW50IiwiU2hpcHBpbmdBZGRyZXNzRWxlbWVudCIsIlBheW1lbnRNZXRob2RNZXNzYWdpbmdFbGVtZW50IiwiQWZmaXJtTWVzc2FnZUVsZW1lbnQiLCJBZnRlcnBheUNsZWFycGF5TWVzc2FnZUVsZW1lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@stripe/react-stripe-js/dist/react-stripe.esm.mjs\n");

/***/ })

};
;